#! /usr/bin/env python2
############################################################
#
# Ce programme ecrit un stream WMO contenant des bulletins
# meteos. Seul les bulletins non envoyes resteront dans 
# le repertoire de travail.
#
# Par: Louis-Philippe Theriault
#      Stagiaire, CMC
#
############################################################

import commands
import os
import sys
import time
import string

sys.path.append(sys.path[0] + '/../lib')
sys.path.append(sys.path[0] + '/../etc')
import utils
import bulletinLib
import imp
import wmoSocketManager

def main():

	# Lecture du fichier de configuration du programme
	if len(sys.argv) == 2:
	        pathCfg = sys.argv[1]
	
	        try:
	                fic_cfg = open(pathCfg,'r')
	                config = imp.load_source('config','/dev/null',fic_cfg)
	                fic_cfg.close()
	        except IOError:
	                print "*** Erreur: Fichier de configuration inexistant, erreur fatale!"
	                sys.exit(-1)
	else:
	        print "*** Erreur: Aucun fichier de config en entree, erreur fatale !\n" + \
	              "            Le chemin du fichier doit etre le chemin complet"
	        sys.exit(-1)
	
	# Init du log
	try:
	        log = utils.initLog(config.primaryLog,config.backupLog)
	except Exception, inst:
	        print "*** Erreur: Creation du log impossible !\n" + str(inst)
	        sys.exit(-1)

	# Test des differents elements de la config (repertoire de travail)
	config.sourceDir = utils.normalizePath(config.sourceDir)
	
	try:
	        utils.testAccess([(config.sourceDir,os.W_OK)])
	except Exception, inst:
	        if inst.args[0] == 'uDef':
	                print "*** Erreur: la parametre suivant \'" + inst.args[1] + "\' est non existant ou les permissions sont erronees"
	                utils.writeLog(log, "*** Erreur: la parametre suivant \'" + inst.args[1] + "\' est non existant",sync = True)
	                sys.exit(-1)
	        else:
	                raise


	# Ouverture du socket...
	localPort 	= config.localPort
	remoteHosts 	= config.remoteHosts
	timeout		= config.timeout
	utils.writeLog(log,"Ouverture du socket...",sync=True)
	
	i = 0
	while True:
		try:
			utils.writeLog(log,"Tentative de connection a " + str(remoteHosts[i]))
			wmoSock = wmoSocketManager.wmoSock(localPort,master=True,remote=(remoteHosts[i]),timeout=timeout)
			break
		except Exception, inst:
			if len(inst.args) == 2 and inst.args[0] == 'uDef' and inst.args[1] == 'Connection impossible, timeout depasse!':
				utils.writeLog(log,"Connection impossible a " + str(remoteHosts[i]))
				i = i + 1

				if i == len(remoteHosts):
					i = 0
			else:
				raise

	utils.writeLog(log,"Succes de l'ouverture du socket!")

	# Init et description des diverses structures
	bulletinsEnAttente 	= []		# Liste des noms de fichier des bulletins a effacer parce qu'ils
						# sont traites et prets a envoyer
	nbBullEnvoyes 	= 0
	sourceDir 	= config.sourceDir	# Repertoire ou arrivent les bulletins
	MAXBULL 	= config.MAXBULL	# Taille max d'un bulletin
	delai		= config.delai		# Delai si aucun fichier en input
	connectionBrisee = False        # True si la connection a lachee recamment

	while True:
		# Si la connection a ete brisee recamment, reconnection a l'hote,
		# puis retraitement des bulletins non envoyes
		if connectionBrisee:
			utils.writeLog(log,"La connection est brisee!")
		        utils.writeLog(log,"Tentative d'ouverture du socket...",sync=True)

			i = 0
			while True:
				try:
					utils.writeLog(log,"Tentative de connection a " + str(remoteHosts[i]))
					wmoSock = wmoSocketManager.wmoSock(localPort,master=True,remote=(remoteHosts[i]),timeout=timeout)
					break
				except Exception, inst:
					if len(inst.args) == 2 and inst.args[0] == 'uDef' and inst.args[1] == 'Connection impossible, timeout depasse!':
						utils.writeLog(log,"Connection impossible a " + str(remoteHosts[i]))
						i = i + 1

						if i == len(remoteHosts):
							i = 0
					else:
						raise

		        utils.writeLog(log,"Succes de l'ouverture du socket!")
			bulletinsEnAttente = []
			connectionBrisee = False

		# Si il reste des bulletins a envoyer, les envoyer
		if len(bulletinsEnAttente) > 0:
			try:
				nbBullEnvoyes = wmoSock.transmitBuffer()
			except Exception, inst:
		                if len(inst.args) == 2 and inst.args[0] == 'uDef' and inst.args[1] == 'La connection est brisee':
                		        connectionBrisee = True
					continue
               			else:
		                        raise


			for bullEnvoye in bulletinsEnAttente[:nbBullEnvoyes]:
				os.remove( sourceDir + bullEnvoye )
				utils.writeLog(log,"Envoi du bulletin <" + sourceDir + bullEnvoye  + ">")

			bulletinsEnAttente = bulletinsEnAttente[nbBullEnvoyes:]

		# Fetch des fichiers a travailler
		bulletinsATraiter = utils.listSubstract( os.listdir(sourceDir) , bulletinsEnAttente )

		# Pause
		if len(bulletinsATraiter) == 0:
			time.sleep(delai)

		# Pour chaque fichier dans le repertoire
		for nomBulletin in bulletinsATraiter:

			# Lecture du fichier
			bulletinFic = os.open(sourceDir + nomBulletin, os.O_RDONLY)
			bulletin = os.read(bulletinFic,MAXBULL)
			os.close(bulletinFic)

			# Envoi du bulletin
			try:
				nbBullEnvoyes = wmoSock.sendBulletin(bulletin,bulletinLib.getType(bulletin))
                        except Exception, inst:
                                if len(inst.args) == 2 and inst.args[0] == 'uDef' and inst.args[1] == 'La connection est brisee':
                                        connectionBrisee = True
                                        break
                                else:
                                        raise

			bulletinsEnAttente.append(nomBulletin)

			# Si le bulletin a ete correctement envoye
			if nbBullEnvoyes > 0:
				# Effacement du(des) fichier(s) envoye(s)
				for bullEnvoye in bulletinsEnAttente[:nbBullEnvoyes]:
					os.remove( sourceDir + bullEnvoye )
					utils.writeLog(log,"Envoi du bulletin <" + sourceDir + bullEnvoye  + ">")

				bulletinsEnAttente = bulletinsEnAttente[nbBullEnvoyes:]

main()			
