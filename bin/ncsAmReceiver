#! /usr/bin/env python2
############################################################
#
# Ce programme lit un stream AM contenant des bulletins
# meteos, effectue des modifications et les ecrit sur le
# disque.
#
# Remplace amtcp2file, avec quelques fonctionnalites 
# enleves.
#
# Par: Louis-Philippe Theriault
#      Stagiaire, CMC
#
############################################################

import commands
import os
import sys
import time
import string

sys.path.append(sys.path[0] + '/../lib')
sys.path.append(sys.path[0] + '/../etc')
import utils
import bulletinLib
import imp
import amSocketManager

# Lecture du fichier de configuration du programme
if len(sys.argv) == 2:
        pathCfg = sys.argv[1]

	try:
		fic_cfg = open(pathCfg,'r')
		config = imp.load_source('config',pathCfg,fic_cfg)
		fic_cfg.close()
	except IOError:
		print "*** Erreur: Fichier de configuration inexistant, erreur fatale!"
		sys.exit(-1)
else:
        print "*** Erreur: Aucun fichier de config en entree, erreur fatale !\n" + \
	      "            Le chemin du fichier doit etre le chemin complet"
        sys.exit(-1)

# Init du log
try:
	log = utils.initLog(config.primaryLog,config.backupLog)
except Exception, inst:
	print "*** Erreur: Creation du log impossible !\n" + str(inst)
	sys.exit(-1)

# Copie des parametres
extension = config.extension
ficCollection = config.ficCollection

# Normalisation des paths
destDir = utils.normalizePath(config.sendDir)
tempDir = utils.normalizePath(config.tempDir)

# Diverses structures contenant les informations cruciales
mapEntetes = {}		# Definie dans bulletinLib
prefixe_nom_bulletin = ""	# Prefixe a inserer avant le nom du bulletin (utilise pour les erreurs)
uneStation = ""		# Station du bulletin courant
uneCle = ""		# Pour la recherche dans la TH
listeBulletins = []	# Liste des bulletins contenus dans le buffer
listeBulletinsModifies = []	# Liste des bulletins une fois traites ainsi que leur nom (tuple: (bulletin,nom,type,origine))
contenuDeBulletin = []  # Contenu du bulletin courant sous forme de liste des lignes du bulletin
unBulletin = ""		# Une bulletin avec les lignes fusionnees
compteur = 0		# Compteur pour les bulletins
connectionBrisee = False	# True si la connection a lachee recamment

# Test des parametres
try:
	utils.testAccess([(destDir,os.W_OK),(ficCollection,os.R_OK),(tempDir,os.W_OK)])
except Exception, inst:
	if inst.args[0] == 'uDef':
		print "*** Erreur: la parametre suivant \'" + inst.args[1] + "\' est non existant ou les permissions sont erronees"
		utils.writeLog(log, "*** Erreur: la parametre suivant \'" + inst.args[1] + "\' est non existant",sync = True)
		sys.exit(-1)
	else:
		raise

# Lecture du fichier de collection
if ficCollection != None:
	try:
		mapEntetes = bulletinLib.chargerFicCollection(ficCollection)
	except Exception:
		utils.writeLog(log,"*** Erreur: Chargement du fichier de collection impossible\n" + Exception,sync=True)
		sys.exit(-1)

# Init de l'entete
bulletinLib.extension = extension
bulletinLib.extensionDynamique = bulletinLib.initExtension()

# Init du socket
utils.writeLog(log,"Tentative d'ouverture du socket...",sync=True)
amSock = amSocketManager.amSock(config.port)
utils.writeLog(log,"Succes de l'ouverture du socket!",sync=True)

while True:
	# Si la connection a ete brisee, l'on ecoute et on attends pour un nouvelle
	if connectionBrisee:
		utils.writeLog(log,"Contenu du reste du buffer (dernier bulletin incomplet) :\n" + amSock.recvBuffer,sync=True)
		utils.writeLog(log,"Tentative d'ouverture du socket...",sync=True)
		amSock = amSocketManager.amSock(config.port)
		utils.writeLog(log,"Succes de l'ouverture du socket!",sync=True)
		connectionBrisee = False

	# Sync du buffer
	try:
		amSock.readBuffer()
	except Exception, inst:
		if len(inst.args) == 2 and inst.args[0] == 'uDef' and inst.args[1] == 'La connection est brisee':
			utils.writeLog(log,"La connection est brisee!")
			utils.writeLog(log,"Traitement du reste du buffer",sync=True)
			connectionBrisee = True			
		else:
			raise

	# Copie des bulletins dans une liste
	while True:
		unBulletin = amSock.getNextBulletin()
		if unBulletin == '':
			break
		listeBulletins.append(unBulletin)

	# Pour chaque bulletins dans la liste des bulletins bruts
	while True:

		if len(listeBulletins) == 0:
			break

		# Extraction du prochain bulletin complet
		unBulletin = listeBulletins.pop()

		# Si le fichier est a modifier ...
		if ficCollection != None and len(unBulletin.splitlines()[0].split()[0]) == 2:

			prefixe_nom_bulletin = ''

			try:

				premierMot = unBulletin.splitlines()[0].split()[0]

				# Lecture du contenu du bulletin
				contenuDeBulletin = unBulletin.splitlines()

				# Si c'est un bulletin FC/FT, possibilite de plusieurs bulletins, donc decoupage en fichiers et reste du traitement
				# saute (il sera effectue lors de la prochaine passe
				if premierMot == "FC" or premierMot == "FT":
					if string.count(string.join(contenuDeBulletin,'\n'),'TAF') > 1:
					# Plus d'un bulletin dans le bulletin, concatenation des bulletins separes avec la liste de bulletins non traites
					# et un saut de boucle
						listeBulletins = listeBulletins + bulletinLib.separerBulletin(contenuDeBulletin,'TAF')
						
						continue

				# Recherche de la station
				uneStation = bulletinLib.getStationMeteo(contenuDeBulletin)

				# Construction de la cle
				if premierMot != "SP":
					uneCle = premierMot + uneStation
				else:
					uneCle = "SA" + uneStation
	
				# Fetch de l'entete a inserer
				if premierMot == "CA" or premierMot == "MA" or premierMot == "RA":
					uneEnteteDeBulletin = "CN00 CWAO "
				else:
					uneEnteteDeBulletin = mapEntetes[uneCle]
	
				# Modif de l'entete
				if len(contenuDeBulletin[0].split()) == 1:
					uneEnteteDeBulletin = premierMot + uneEnteteDeBulletin + bulletinLib.getFormattedSystemTime()
				elif len(contenuDeBulletin[0].split()) == 2:
					uneEnteteDeBulletin = premierMot + uneEnteteDeBulletin + contenuDeBulletin[0].split()[1]
				else:
					uneEnteteDeBulletin = premierMot + uneEnteteDeBulletin + contenuDeBulletin[0].split()[1] + ' ' + contenuDeBulletin[0].split()[2] 
	
				# Assignement de l'entete modifiee
				contenuDeBulletin[0] = uneEnteteDeBulletin
	
				# Si un "SM" ou "SI"  inserer la ligne "AAXX jjhhmm4"
				if config.SMHeaderFormat and (premierMot == "SM" or premierMot == "SI"):
					contenuDeBulletin.insert(1, "AAXX " + contenuDeBulletin[0].split()[2][0:4] + "4")

			except KeyError:
				# Une entete n'a pu etre trouvee, erreur!
				contenuDeBulletin.insert(0,"### Entete non trouvee dans le fichier de collection")
				contenuDeBulletin.insert(0,"ERROR BULLETIN")

				prefixe_nom_bulletin = 'ERROR_BULLETIN_'
				uneEnteteDeBulletin = contenuDeBulletin[2]

				utils.writeLog(log,"*** Erreur : Station <" + uneStation + "> non trouvee avec prefixe <" + premierMot + ">")
				
				unBulletin = string.join(contenuDeBulletin,'\n')
				utils.writeLog(log,"Bulletin:\n" + unBulletin)
				listeBulletinsModifies.append( (unBulletin,prefixe_nom_bulletin + uneEnteteDeBulletin + '_' + uneStation,'ERROR','ERROR') )
				continue
			except Exception, inst:
		                if inst.args[0] == 'StationNonTrouvee':
	                	        contenuDeBulletin.insert(0,"### Pattern de station non trouve ou non specifie")
					contenuDeBulletin.insert(0,"ERROR BULLETIN")

					prefixe_nom_bulletin = 'ERROR_BULLETIN_'
					uneEnteteDeBulletin = contenuDeBulletin[2]

					extensionFichier = bulletinLib.getExtension('ERROR','ERROR')
					uneStation = 'UNKNOWN'

					utils.writeLog(log,"*** Erreur : Pattern de station non trouve !")

					unBulletin = string.join(contenuDeBulletin,'\n')
					utils.writeLog(log,"Bulletin:\n" + unBulletin)
					listeBulletinsModifies.append( (unBulletin,prefixe_nom_bulletin + uneEnteteDeBulletin ,'ERROR','ERROR') )
					continue
				else:
					utils.writeLog(log,"*** Erreur         : " + str(Exception))
					utils.writeLog(log,"*** Erreur inconnue: " + str(inst))

					unBulletin = string.join(contenuDeBulletin,'\n')
					utils.writeLog(log,"Bulletin:\n" + unBulletin)
					listeBulletinsModifies.append( (unBulletin,"ERROR_BULLETIN_" + contenuDeBulletin[0],'ERROR','ERROR') )
					continue

			# Assignement du bulletin final
			unBulletin = string.join(contenuDeBulletin,'\n')

			listeBulletinsModifies.append( (unBulletin,uneEnteteDeBulletin + '_' + uneStation,uneEnteteDeBulletin[0:2],uneEnteteDeBulletin.split()[1]) )
		elif ficCollection == None:
			listeBulletinsModifies.append( (unBulletin,unBulletin.splitlines()[0],'NONE',unBulletin.splitlines()[0][0:2]) )
		else:
		# Le premier nom contient plus de 2 lettres, aucune modification est requise
			try:
				listeBulletinsModifies.append( (unBulletin,unBulletin.splitlines()[0],unBulletin.splitlines()[0][0:2],unBulletin.splitlines()[0].split()[1]) )
			except IndexError:
				listeBulletinsModifies.append( (unBulletin,unBulletin.splitlines()[0],'ERROR','ERROR') )
				utils.writeLog(log,"*** Erreur : Manipulation du bulletin ambigue")
				utils.writeLog(log,"*** Exception: " + str(inst.args[0]))
				utils.writeLog(log,"Bulletin :\n" + unBulletin, sync=True)

	# Ecriture des bulletins sur le disque
	while True:
		if len(listeBulletinsModifies) == 0:
			break

		compteur = compteur + 1
		if compteur > 99999:
			compteur = 1
			
			# Ecrasement de l'ancien log pour sauver de la place...
			os.close(log)
			log = utils.initLog(config.primaryLog,config.backupLog)

		(unBulletin,nomFic,type,origine) = listeBulletinsModifies.pop()

		try:
			nomFic = (nomFic + ' ' + string.zfill(compteur,5) + bulletinLib.getExtension(type,origine)).replace(' ','_').replace('__','_')
			unFichier = os.open( tempDir + nomFic , os.O_CREAT | os.O_WRONLY )

			os.write( unFichier , unBulletin )
			os.close( unFichier )
			os.chmod(tempDir + nomFic,0644)

			os.rename( tempDir + nomFic , destDir + nomFic )

			# Le transfert du fichier est un succes
			utils.writeLog(log,'Ecriture du fichier <' + destDir + nomFic + '>')	

		except OSError, inst:

			utils.writeLog(log,"*** Erreur : Manipulation du fichier impossible! (Ecriture avec un nom non standard)")
			utils.writeLog(log,"*** Exception: " + str(inst.args[0]))
			utils.writeLog(log,"Bulletin :\n" + unBulletin, sync=True)

			nomFic = 'ERROR_BULLETIN_UNPRINTABLE_HEADER_' + string.zfill(compteur,5) + bulletinLib.getExtension(type,origine)
			unFichier = os.open( tempDir + nomFic , os.O_CREAT | os.O_WRONLY )

			os.write( unFichier , unBulletin )
                        os.close( unFichier )
                        os.chmod(tempDir + nomFic,0644)

                        os.rename( tempDir + nomFic , destDir + nomFic )

                        # Le transfert du fichier est un succes
                        utils.writeLog(log,'Ecriture du fichier <' + destDir + nomFic + '>')

