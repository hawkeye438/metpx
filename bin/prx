#! /usr/bin/env python2
# -*- coding: iso-8859-1 -*-

"""
  File Exchange Tracker - File Receiver
	(aka, PDS ++ )

 SPEC:
  read file names in rx directory tree according to source configuration in etc/rx
  apply a priority scheme:
	send off high critical priority messages ASAP.
       keep from low priority messages from starving. 
  
  once file names are chosen, link them into the db, and all relevant client directories.

  2005/01/22 - Initial Version, Peter Silva
"""



import os
import os.path
import time
import sys



sys.path.insert(1,sys.path[0] + '/../lib')
sys.path.insert(1,sys.path[0] + '/../lib/importedLibs')

from optparse import OptionParser
import log
import fet

logger = {}

def ingestDir(d,s,logger):
  """
  given a single directory, read all the non-hidden entries and
  attempt to ingest them.  

  if it works, remove it.
  If not, just leave it there

  pay attention to the time, and abort if it takes too long

  FIXME: Doesn't pay attention to partially written files.
     uses the PDS method (chmod), preference would be to rename.
     could use given code as is, if partial files start with . (hidden.)
  """

  numfiles=0

  logger.writeLog(logger.DEBUG, " examen de répertoire " + d + " débute." )
  for r in os.listdir(d):
    if r[0] == '.' or not os.access(r, os.R_OK):
      continue
    i=fet.ingestName(r,s) # map reception name to ingest name
    rr=d + "/" + r
    if fet.ingest(i,rr, logger) == 1:
      logger.writeLog(logger.INFO, "fichier " + rr + " ingérée comme " + i)
      os.unlink( rr )
    else:
      logger.writeLog(logger.ERROR, "fichier " + rr + " non-ingérable " )
    numfiles = numfiles + 1

  return numfiles



def checkSource(s, sources):
  """look for source directories with data to ingest. Trigger ingestion.

     Priority scheduling scheme.
        -- scan all at pri x
	   if found no files at pri x, then go to x+1
	   if > thresh files fount at pri x, then  go to x+1

     thresh == 100
  """

  global logger


  if not os.path.exists( fet.FET_DATA + fet.FET_RX):
     logger.writeLog(logger.FATAL, "ingest queue directory does not exist" )
     return

  # initialize history array.
  dmodified = {}
  logger.writeLog(logger.INFO, "Début du programme, initialization completée")

  while(1):

    dname = fet.sourceQDirName(s)
      
    if dname == '':
      continue
  
    fet.createDir(dname)
    dstat=os.stat( dname );

    # if the dir has changed, then ingest.
    if not dname in dmodified.keys():
      dmodified[ dname ]= 0

    if dstat.st_mtime > dmodified[ dname ] :
      #print "New files!"
      os.chdir(dname)
      dmodified[ dname ] = dstat.st_mtime
      ingestDir( dname, s, logger )

    time.sleep(1)      

usage="%prog [--data dir][-e etc] <source> (start|stop)\n"
parser = OptionParser(usage)

fet.addStandardOptions(parser)

options,args = parser.parse_args()


if len(sys.argv) < 2:
  print "FATAL: fetrx expects the name of a source as a single argument"
  sys.exit(1)

if ( len(sys.argv) < 3 ) or not (( sys.argv[2] == 'stop' ) or ( sys.argv[2] == 'start' )):
  print "USAGE: fetrx <source> (start|stop)"
  sys.exit(1)

s = sys.argv[1]
cmd = sys.argv[2]

logger = log.log( fet.FET_DATA + "log/" + os.path.basename(sys.argv[0]) + "_" + s )

fet.startup(options,logger)

if s not in fet.sources.keys():
  print "FATAL: " + s + " source not configured or is set inactive"
  sys.exit(1)

fet.lockStopOrDie( fet.FET_DATA + fet.FET_RX + s + '/.lock' , cmd )

checkSource( s, fet.sources )


