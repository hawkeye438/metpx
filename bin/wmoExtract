#! /usr/bin/env python2
############################################################
#
# Ce petit programme execute en boucle un parcours dans le
# repertoire de travail ou arrive les bulletins meteo,
# et effectue le decoupage selon les specs sur wiki.
#
# Par: Louis-Philippe Theriault
#      Stagiaire, CMC
#
############################################################

import commands
import os
import sys
import time
import string

sys.path.append(sys.path[0] + '/../lib')
sys.path.append(sys.path[0] + '/../etc')
import utils
import bulletinLib
import imp

# Lecture du fichier de configuration du programme
if len(sys.argv) == 2:
        pathCfg = sys.argv[1]

	try:
		fic_cfg = open(pathCfg,'r')
		config = imp.load_source('config','/dev/null',fic_cfg)
		fic_cfg.close()
	except IOError:
		print "*** Erreur: Fichier de configuration inexistant, erreur fatale!"
		sys.exit(-1)
else:
        print "*** Erreur: Aucun fichier de config en entree, erreur fatale !\n" + \
	      "            Le chemin du fichier doit etre le chemin complet"
        sys.exit(-1)

# Normalization des paths
config.sourceDir = utils.normalizePath(config.sourceDir)
config.destDir = utils.normalizePath(config.destDir)

# Init du log
log = utils.initLog(config.primaryLog,config.backupLog)

# Diverses structures contenant les informations cruciales
listeNomFichiers = []	# Liste des fichiers contenus dans le repertoire de travail
mapFichiers = {}	# Map des fichiers, pointant sur leur file desc, contenu
			# et nom de fichier s'il y a lieu
prefixe_nom_bulletin = ""	# Prefixe a inserer avant le nom du bulletin (utilise pour les erreurs)
contenuDeBulletin = []  # Contenu du bulletin courant sous forme de liste des lignes du bulletin
toutUnFichier = ""	# Contenu complet d'un fichier sous forme de string
unBulletin = ""		# Une bulletin avec les lignes fusionnees
lngFichier = 0		# Longueur du fichier lu
posDansFic = 0		# Position courante dans le fichier sous forme de string
enteteDecoupage = ""	# Entete contenant les "****XXXXXXXXXX****\n" pour le prochain bulletin
lngBull = 0		# Longueur du prochain bulletin
compteur = 1		# Compteur pour les nom de fichiers

# Test des parametres
try:
	utils.testAccess([(config.destDir,os.W_OK),(config.sourceDir,os.W_OK)])
except Exception, inst:
	if inst.args[0] == 'uDef':
		utils.writeLog(log, "*** Erreur: la parametre suivant \'" + inst.args[1] + "\' est non existant",sync = True)
	else:
		raise

# Init de l'extension
bulletinLib.extension = config.extension
bulletinLib.extensionDynamique = bulletinLib.initExtension()

while True:

	# Init des diverses variables
	listeNomFichiers = []
	mapFichiers = {}

	# Lecture des bulletins dans le repertoire d'entree
	listeNomFichiers = os.listdir(config.sourceDir)
	
	# S'il n'y a pas de nouveaux fichier, l'on sleep <delai> secondes
	# puis l'on recommence la boucle
	if len(listeNomFichiers) < config.nbFicMin: 
		time.sleep(config.delai)
		continue

	# Ouverture des nouveau fichiers en mode lecture/ecriture
	mapFichiers = utils.getMapFicOuv(listeNomFichiers,config.sourceDir,10,os.O_RDWR)

	# Pour chaque fichier
	for nomFichier in mapFichiers.keys():

		# Lecture du contenu d'un fichier
		uneLecture = "nonVide"
		toutUnFichier = ""

		try:
			while uneLecture != '':
				uneLecture = os.read(mapFichiers[nomFichier]['fileDesc'],32768)
				toutUnFichier = toutUnFichier + uneLecture
	
			posDansFic = 0
		except Exception, inst:
			utils.writeLog(log,'*** Erreur : Lecture de <' + nomFichier + '> impossible')
			utils.writeLog(log,'Exception : ' + str(Exception))
                        utils.writeLog(lgo,'Args      : ' + str(inst),sync=True)
			continue
	
		utils.writeLog(log,'Lecture du fichier <' + config.sourceDir + nomFichier + '>')
		lngFichier = len(toutUnFichier)

		try:

			# Tant que l'on est pas a la fin du fichier
			while posDansFic < lngFichier:
	
				# Lecture et parsing des premiers 19 caracteres
				enteteDecoupage = toutUnFichier[posDansFic:posDansFic + 19]
				lngBull = int(enteteDecoupage[4:14])
				posDansFic = posDansFic + 19
	
				# Lecture de <lngBull> caracteres
				unBulletin = toutUnFichier[posDansFic:posDansFic + lngBull]
				posDansFic = posDansFic + lngBull
	
				# S'il y a lieu remplacement des <CR><CR><LF> pour des <LF>
				if config.formattageFinDeLigne:
		                        if unBulletin.find('BUFR') == -1 and unBulletin.find('GRIB') == -1:
	        	                        unBulletin = unBulletin.replace('\r\r\n','\n')
					else:
						# Si le bulletin est un BUFR, l'on remplace le premier set,
						# puis le dernier (apres le 7777) s'il y a lieu
						unBulletin = unBulletin.replace('\r\r\n','\n',1)
						unBulletin = unBulletin[:unBulletin.rfind('7777')] + unBulletin[unBulletin.rfind('7777'):].replace('\r\r\n','\n')
	
				# Creation du nom de fichier de destination
				nomFicDest = (unBulletin.splitlines()[0] + '_' + string.zfill(compteur,6) + 	\
					bulletinLib.getExtension(unBulletin.splitlines()[0].split()[0][0:2],   	\
					unBulletin.splitlines()[0].split()[1])).replace(' ','_')
	
				# Mise a jour du compteur
				compteur = compteur + 1
				if compteur > 999999:
					compteur = 1
	
				# Ecriture/fermeture du bulletin
				bullDest = os.open( config.sourceDir + nomFicDest , os.O_WRONLY | os.O_CREAT )
				os.write(bullDest,unBulletin)
				os.close(bullDest)
				os.chmod(config.sourceDir + nomFicDest , 0644)
				os.rename( config.sourceDir + nomFicDest , config.destDir + nomFicDest )

				utils.writeLog(log,"Ecriture du bulletin <" + config.sourceDir + nomFicDest +">")

		except Exception, inst:
				utils.writeLog(log,'*** Erreur : Probleme dans le fichier ' + config.sourceDir + nomFichier)
				utils.writeLog(log,'Exception : ' + str(Exception))
				utils.writeLog(lgo,'Args      : ' + str(inst),sync=True)
				os.copy( config.sourceDir + nomFichier , config.destDir + 'ERROR_' + nomFichier )

		# Fermeture du fichier et effacement
		os.close(mapFichiers[nomFichier]['fileDesc'])
		os.remove(config.sourceDir + nomFichier)
