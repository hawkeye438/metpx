#! /usr/bin/env python
"""
MetPX Copyright (C) 2004-2006  Environment Canada
MetPX comes with ABSOLUTELY NO WARRANTY; For details type see the file 
named COPYING in the root of the source directory tree.

#############################################################################################
#
# @name   : retreiveDataFromMachine.py
#
# @author :  Nicholas Lemay
#
# @since  :  2007-02-19, last updated on January 3rd 2008 
#
# @about  : This script is to be used to synchronise 
#           the different files that are generated by pxStats
#           between 2 different machines.
#
#           Very usefull when one of many mirror machines goes down or 
#           when setting up a mirror machine.     
#
# @usage  : This program can be called from command-line.
#          
#           Call examples :                   
#               python pickleViewer.py px machineName 
#              
##############################################################################################
"""

import commands, os, sys 
sys.path.insert(1, sys.path[0] + '/../../')

from pxStats.lib.StatsPaths import StatsPaths
from pxStats.lib.StatsConfigParameters import StatsConfigParameters   
from pxStats.lib.MachineConfigParameters import MachineConfigParameters
from pxStats.lib.GeneralStatsLibraryMethods import GeneralStatsLibraryMethods


LOCAL_MACHINE = os.uname()[1]


def transferLogFiles():
    """
        Log files will not be tansferred if local machine
        is not designed to be a pickling machine. 
        If log files are to be transferred, they will be straight
        from the source."
    """
    
    parameters = StatsConfigParameters()    
    machineParameters = MachineConfigParameters()
    machineParameters.getParametersFromMachineConfigurationFile()
    parameters.getAllParameters()
    individualSourceMachines   = machineParameters.getMachinesAssociatedWithListOfTags( parameters.sourceMachinesTags )
    individualPicklingMachines = machineParameters.getMachinesAssociatedWithListOfTags( parameters.picklingMachines )
        
    for sourceMachine,picklingMachine in map( None, individualSourceMachines, individualPicklingMachines ) :      
               
        if picklingMachine == LOCAL_MACHINE :#pickling to be done here  
            
            userName = machineParameters.getUserNameForMachine(sourceMachine)
            remoteLogPath = StatsPaths.getPXPathFromMachine( StatsPaths.PXLOG, sourceMachine, userName )
            
            
            print  "rsync -avzr --delete-before -e ssh %s@%s:%s %s%s/ " %( userName , sourceMachine,remoteLogPath , StatsPaths.STATSLOGS, sourceMachine  )
            output = commands.getoutput( "rsync -avzr --delete-before -e ssh %s@%s:%s %s%s/ " %( userName , sourceMachine, remoteLogPath, StatsPaths.STATSLOGS, sourceMachine  ) )
            print output
    
    
    
def getLocalPathsToSynchronise():
    """
        @summary : Returns the list of local paths that are 
                   required to with the remote machine we 
                   want to be synchronised with.
    """
    
    paths = [ StatsPaths.STATSMONITORING , StatsPaths.STATSGRAPHS , StatsPaths.STATSPICKLES, StatsPaths.STATSCURRENTDB, StatsPaths.STATSDBBACKUPS , StatsPaths.STATSCURRENTDBUPDATES, StatsPaths.STATSDBUPDATESBACKUPS ]
    
    return paths 


           
def buildLocalPaths( localPaths )  :
    """     
        @summary : Builds all the specified paths.
                   ( makedirs ) 
    """
    
    for path in localPaths:
        if not os.path.isdir( path ) :            
            print path
            os.makedirs( path )
     
     
     
def getConfigFiles() :
    """            
        @summary : Returns the list of config files to synchronise.
        
        @return  : Returns the list of config files to synchronise.
         
    """
    
    configFiles = []
    configFiles.append( StatsPaths.STATSMONITORING + 'maxSettings.conf' )
    configFiles.append( StatsPaths.STATSMONITORING + 'previousCrontab' )      
    configFiles.append( StatsPaths.STATSMONITORING + 'previousFileChecksums')
    
    return configFiles



def transfer( login, machine ):
    """
        @summary : Transfers all the required files
                   from specified machine into local 
                   machine.
    
                   Every task is done 10 times.
        
                   This is done in hope that everything 
                   downloaded will be as coherent as possible.
        
                   If a large amount of file is to 
                   be transferred, some files that were downloaded
                   at the beginning of the transfer,wich can take 
                   up to a few hours,might not be as up to date as 
                   the file downloaded towards the end of the transfer  
   
           
    """    
    
    localPaths = getLocalPathsToSynchronise()
    buildLocalPaths( localPaths )
    configFiles = getConfigFiles()
            
    for i in range( 10 ):
                
        transferLogFiles()
        
        for localPath in localPaths :
            remotePath = StatsPaths.getStatsPathFromMachine( localPath, machine, login )
            print "rsync -avzr  --delete-before -e ssh %s@%s:%s %s"  %( login, machine, remotePath, localPath )
            output = commands.getoutput( "rsync -avzr  --delete-before -e ssh %s@%s:%s %s"  %( login, machine, remotePath, localPath ) )
            print output        
             
            
    for configfile in configFiles:
        #get real path 
        localPath = os.path.dirname( configfile )
        fileName  = os.path.basename( configfile )
        remotePath = StatsPaths.getStatsPathFromMachine( localPath, machine, login )
        
        print "rsync -avzr  --delete-before -e ssh %s@%s:%s %s"  %( login, machine, remotePath + fileName, localPath + fileName )
        output = commands.getoutput( "rsync -avzr  --delete-before -e ssh %s@%s:%s %s"  %( login, machine, remotePath + fileName, localPath + fileName ) )
        print output       
         
    
    
def main():
    """
        Parses parameters then calls 
        the tranferMethod.
    """
    
    login   = ""
    machine = ""
    
    if len( sys.argv ) == 3   :
        
        login   = sys.argv[1]
        machine = sys.argv[2]     
        transfer( login, machine )
        
    else:
        print "#######################################################################################################"
        print "#"
        print "#    Help for retreiveDataFromMachine.py"
        print "#"
        print "#    This program is to be used to transfer all of the important stats files"
        print "#    from a remote machine to the local machine."
        print "#" 
        print "#    If large transfers are to be done, program may take many hours to complete."
        print "#    Output from every operation will be printed as to let the user see exactly what is going on"
        print "#    and allow errors to be detected."
        print "#"
        print "#    Examples : invalid login or ssh other ssh errors"
        print "#" 
        print "#    This will also serve as to take out the guesswork as to why the program is taking so long to complete."
        print "#"
        print "#    Log files will not be tansferred if local machine is not designed to be a pickling machine. "
        print "#    If log files are to be transferred, they will be transferred straight from the source."
        print "#"
        print "#    *** Make sure %sconfig is filled properly prior to running this script !!! ***"%StatsPaths.STATSETC
        print "#    *** Consult pxStats documentation if you are unsure how to fill %sconfig.  ***"%StatsPaths.STATSETC
        print "#"
        print "#"    
        print "#"
        print "#    Usage  : Program must receive exactly two arguments."
        print "#" 
        print "#    Example : python retreiveDataFromMachine.py login machineName "   
        print "#"      
        print "#######################################################################################################"
        print ""
        print ""
        print ""
        sys.exit()
    
      
    
if __name__ == "__main__":
    main()    