
for files that change:

algorithm assumed:
	- for each ´block´ (blocksize interesting) generate a signature.
	- when a subscriber reads an announcement, it includes the signature.
	- he compares the signatures on the file he already has, and updates it to match.


the zsync algorithm is the right idea, can perhaps use it directly.

zsync is available in repositories.  
and zsync(1) is the existing download client.  
zsyncmake(1) builds the signatures, with a programmable block size. 

It looks ike zsync is usable as is?

downside:  need zsync on windows and mac for downloads, dependency a pain.


we send the signatures in the announcements, rather than posting on the site.
If we set the blocksize high, then for files < 1 block, there is no signature.

I hate forking...  don´t want to be forking zsyncmake for every product...
even if we do not use zsync itself, might want to be compatible... so use
a third party format and have a comparable.  1st implementation would do
forking, 2nd version might replicate the algorithm internally.

perhaps we have a threshold, if the file is less than a megabyte, we just send
the new one. if it is bigger, 
zs

The intent is not to replicate source trees, but large data sets.  
	- for most cases (when writing a new file) we do not want extra overhead.
	- target is large files that change, for small ones, transfer again, is not a big deal.
	- want to minimize signature size (as will travel with notifications.)
	- so set a block siz for s


