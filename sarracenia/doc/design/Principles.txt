
Status: Pre-Draft

Overview:
MetPX-Sarracenia is a data duplication or distribution engine that leverages existing 
standard technologies (sftp and web servers and AMQP brokers) to achieve real-time message 
delivery and end to end transparency in file transfers.  Whereas in Sundew, each 
switch is a standalone configuration which transforms data in complex ways, in 
sarracenia, the data sources establish a structure which is carried through any 
number of intervening switches until they arrive at a consumer.  The consumer can 
provide explicit acknowledgement that propagates back through the network to the 
source.  

Whereas traditional file switching is a point-to-point affair where knowledge is only
between each segment, in Sarracenia, information flows from end to end in both directions.
At it's heart, sarracenia exposes a tree of web accessible folders (WAF), using 
any standard HTTP or SFTP server .  Weather applications are soft real-time, 
where data should be delivered as quickly as possible to the next hop, and 
minutes, perhaps seconds, count.  The standard web push technologies, ATOM, RSS, 
etc... are actually polling technologies that when used in low latency applications 
consume a great deal of bandwidth an overhead.  For exactly these reasons, those 
standards stipulate a minimum polling interval of five minutes.   Advanced Message 
Queueing Protocol (AMQP) messaging brings true push to notifications, and makes 
real-time sending far more efficient.

insert diagram here.

Sources of data announce their products, switching systems pull the data onto their 
WAF trees, and then announce their trees for downstream clients.  in some topologies,
it is necessary for the source to push the data to a switching system.  When clients 
download data, they write a log message back to the server.  Servers are configured 
to forward those client log messages back through the intervening servers back to 
the source.  The Source can see the entire path that the data took to get to each 
client.  With traditional switching applications, sources only see that they delivered 
to the first hop in a chain. Beyond that first hop, routing is opaque, and tracing
the path of data required assistance from administrators of each intervening system.  
With Sarracenia's log forwarding, the switching network is completely transparent 
to the sources, in that they can see where it went.  With end to end logs, diagnostics 
are vastly simplified for everyone.

For large files / high performance, files are segmented on ingest if they are sufficiently 
large to make this worthwhile.  Each file can traverse the switch network independently, 
and reassembly is only needed at end points.   A file of sufficient size will announce 
the availability of several segments for transfer, multiple threads or transfer nodes 
will pick up segments and transfer them.  The more segments available, the higher 
the parallelism of the transfer.   In many cases, Sarracenia manages parallelism 
and network usage without explicit user intervention.  As intervening switches 
do not store and forward entire files, the maximum file size which can traverse 
the network is maximized.

The system is expected to reduce management burden in a 24x7 monitored fully
operational environment for configuration of data delivery.

The principles below are not in order (yet?) maybe we will do that later.
not sure about priorities, just number to be able to refer to them.

Principles which guide (reflect?) design/implementation:

1.  The switch (any number of switches) are transparent.
    Put another way:
    The source is in charge of the data they provide.

    The source determines the distribution (scope, and permissions)
   
    The source can obtain any information about themselves.


2.  AMQP brokers do not transfer any user data, just metadata.

    reasoning:
    need to keep the messages small so that the forwarding rate is high.
    large messages will gum up the works.  also permissions become interesting.
    end up with a 'maximum size' threshold, and implementing two methods for everything.



3.  Admin changes propagate. No change should be unique to a host
    you should not have to do dsh, or px-push.  
    That sort of management is built in. the message bus is there for that.
    might use 'scope' to have commands propagate through multiple clusters.


4.  Logs are data.

   "It is not enough for justice to be done.  Justice must be seen to be done."

    It is not enough for data to be delivered.  That delivery must be logged,
    and that log must be returned to the source.


5.  This is a data distribution tool, not a file tree replicator.

    we do not care:
	 -- who owned it originally.
    	 -- when it was modified.
    	 -- it's original permission bits.
         -- what ACL's it has (they aren't relevant on the destination.)
    	 -- extended attributes. (portability, win,mac,lin,netapp?)

    I´m wondering about this one, perhaps extended attributes are important?


6. Not worried about performance in phase 1
    -- performance is enabled by the scalability of the design.
          -- segmentation/re-assembly provides multi-threading.
	  -- segmentation means bigger files transfer with greater parallelism.
	     adds multiple streams when that is worthwhile, uses a single stream
	     when that makes sense.
	  -- validation provides source bandwidth limiting.

    -- need to prove all the moving parts work together first.

    -- much later, may return to see how to make each transfer engine
       go faster.  


7. This is not a web application, this is not an FTP server.

   this is an application that uses HTTP as one of the transport protocols, but
   that's all.  It is not trying to be a web site, any more than it is trying
   to be an sftp server.  it is something else.  dunno what exactly.


8. Common management not needed, just pass logs around.
   Different groups will manage different switches.
   We are trying to make a switch that others can easily adopt.
   That means they can install and go.

   when we interconnect switches, they become a source for us.
   log messages are routed to the data sources, so they get our logs on their
   data.  (this can be turned of if there are security objections.)


9. It needs to run anywhere. It´s user visible, needs to be a bit friendly.

   Sundew is, well, let´s just call it nerd-centric.
   Sarracenia will also be that way, but less so.  It needs to be used
   by end users (at least the client.) so it needs a bit more UI.

	ubuntu,centos -- primary.
        but windows also.

	it needs to be easy to set up, both client and server.
	   (this aspect dealt with in packaging)
   


some references:
	CAP theorem
	Fallacies of Distributed Computing.

