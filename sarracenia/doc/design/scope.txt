
Status: Pre-Draft

scope is the logical name of a switching cluster, which must be unique in a network.
Each cluster has channels to connect to either other scopes, or single accounts.
account is the logical name of a client, which must be unique in a network.



account2scope.conf: -- maps accounts to scopes.
  <scope> <account>,<account>, ...
  
  not sure how this is maintained, likely by spying on post messages
  as they go by?


scope2channel.conf -- maps scopes to channels
  <channel/scope> <scope>,<scope>,...

  perhaps a manually configured file, changes rarely, involves inter cluster
  relationships?


This is a switch global account file, to be used by validation scripts.
don´t know how it is created yet, perhaps manual, perhaps auto.

There are two kinds of channels:
	- inter-cluster / inter-scope / inter-switch.
	- source / account 


For a source channel, validation will insist that all postings received are 
from that source.

for an inter-cluster/inter-scope/inter-switch channel:
   the scopes2channel.conf file indicates scopes are valid from that channel.

   all postings will need to be from accounts listed in one of the valid scopes, 
   so search the scopes_accounts.conf file for each valid scope for that channel

   when log messages are returned:
   The log2src process consults these files and determines where to route log messages.


-------------- earlier stuff.

NOTe: SCOPE ... permanent dd.
    permanent URL´s for use in DOI´s.  archiving? backups?
    new scope.

    this destination strips out the dates from the tree on receipt.
    

upshot:

Sources control who sees their data.  There is a 'Routing' that sources 
need to say 'where' it gets posted.  to get things posted to ´internet´ 
vs. ´internal´ etc...

Is it better to:
	-  post once, listing multiple scopes?
	-  post once for each scope?

answer: it feels like listing multiple scopes ensures that the data 
is only transferred once from origin.


Each account has a home 'scope' which is the only place they can 
insert messages in.
	- do not want common passwords used on inside and outside 
          (hence single scope for insertion.)


when receiving a log message, it will be sent to the appropriate 
exchange on the home scope. 

Users are ´scope-local´ but visible to other scopes.  Downstream
scopes do not have pw for user Alice in scope A.   Assumption is
that someone else might control account assignment in other scopes.
So user name clashes are possible.  There might be an Alice in 
scope A, and in scope AA.

Any one scope may not be able to ¨see¨ all other scopes,
it has to know ´routes´ to other scopes.


what are distributions/scopes?
	- does each source have a permission per scope ?
	- does each source have a disk space allocation per scope?
	- if you just set the allocation to 0, that's a permission.

	some more examples:  ec, science, internet, warning

	original ddi will be deployed in ec, but will be tied into 
        science.gc.ca switches.  and be able to push to 
        ddi.science.gc.ca so all of GoC will be reachable.

	warnings: high priority queue. only very few able to post there.
		how this works is unclear.

	

Admin functions:
	alias scope a to scope b.
	maintain a list of scope routes?
	or have it all be dynamic and learning?

internal servers, or internet facing?


for each layer of switching, a list of valid scopes is defined?
scope corresponds to an exchange to which a given switch posts (outputs of validation)

	- validate distribution/scope list (header?)
		internet vs. escience (comma separated list) vs. warning?
		is scope is invalid: reject.

		are there scope permissions ? some source can only send to 


-------- inter scope channel -------------------
to go from scope A to scope B, on scope A.

set up a an exchange:
to_B, and from_B (log B)?

on B, the complementary exchanges are established:
to_A and from_A

If the source has specified ´B´ as a destination scope, then
SARA places the announcement on to_B.

If A ´knows´ that C is reachable through B, then also put on to_B.

either a dd_sender on A or a dd_subscribe on B is subscribed to to_B
and does the data transfer. 

The dd_sender on A will then re-announce... where?
	as B(!) on from_A ? on B ??
	as A on from_A ? ?? <-- makes more sense.
		then a SARA (with no fetch, since the file is delivered)
		picks it up from exchange from_A and posts to xPublic

		(since this is a destination scope for the message)
			or do this unconditionally.
		it makes sense from permission perspective,
		scope A should only be able to post to from_A...

		so admin/sender user on <scope> would be something 
		like dd<scope>.  ddA.

if a dd_subscribe on b does the transfer, then it is logged as
ddB on B. 

-------- inter scope channel  -------------------

-------- no: scope as priority mechanism -------------------

    If we create a wxwarn scope, then warnings go through that scope.
    i think this is not good.  have a priority mechanism per source.

-------- scope as priority mechanism -------------------
    if send to a warning scope it might just set the priority when copied to the
    common exchange, not requiring separate exchanges downstream.

-------- scope as username of switching layer -----------------
try:
	is scope the username of each switching layer?  ssc_ddsr, ssc_ddi, ssc_dd
	each scope has an exchange scope_ssc_ddsr, scope_ssc_ddi, scope_ssc_dd.
	what about warnings?

-------- scope as username of switching layer -----------------





Scenarios:


want to transport a really large file (terabytes.)
	target scope of ddsr (the parallel switching array.)



why check scope/distribution?
	scopes:  science, internet, warnings?

	correspond to exchanges. where things get posted.
	most source cannot post 

	if we have a 'warnings' scope, then limit who can post to it.
	

transitivity
	there is an switch in EC that hands off to a switch in SSC an sr,
	that hands off to a public facing switch.

	that means each switch that connects to another one needs to pass
        the list of known scopes back.

	v01.cfg.scopes.get
	issued from a client, requests the list of scopes of the server.
