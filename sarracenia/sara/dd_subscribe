#!/usr/bin/python3
#
# This file is part of sarracenia.
# The sarracenia suite is Free and is proudly provided by the Government of Canada
# Copyright (C) Her Majesty The Queen in Right of Canada, Environment Canada, 2008-2015
#
# Questions or bugs report: dps-client@ec.gc.ca
# sarracenia repository: git://git.code.sf.net/p/metpx/git
# Documentation: http://metpx.sourceforge.net/#SaraDocumentation
#
# dd_subscribe.py : python3 program allowing users to download product from dd.weather.gc.ca
#                   as soon as they are made available (through amqp notifications)
#
#
# Code contributed by:
#  Michel Grenier - Shared Services Canada
#  Jun Hu         - Shared Services Canada
#  Last Changed   : Sep 22 10:41:32 EDT 2015
#  Last Revision  : Sep 22 10:41:32 EDT 2015
#
########################################################################
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 2 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful, 
#  but WITHOUT ANY WARRANTY; without even the implied warranty of 
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the 
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software
#  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307  USA
#
#

import urllib, logging, logging.handlers, os, random, re, signal, string, sys, time, getopt
import calendar,socket,urllib.parse
import urllib.request, urllib.error
import stat
import amqplib.client_0_8 as amqp
from   hashlib import md5

#============================================================
# usage example
#
# python dd_subscribe.py configfile.conf

#============================================================

# ==========
# HostConnect
# ==========

class HostConnect:

   def __init__(self, logger = None):

       self.asleep     = False
       self.loop       = True

       self.connection = None
       self.channel    = None
       self.ssl        = False

       self.logger     = logger

       self.protocol   = 'amqp'
       self.host       = 'localhost'
       self.port       = None
       self.user       = 'guest'
       self.passwd     = 'guest'

       self.rebuilds   = []
       self.toclose    = []

       self.sleeping   = None

   def add_build(self,func):
       self.rebuilds.append(func)

   def add_sleeping(self,func):
       self.sleeping = func
       
   def close(self):
       for channel in self.toclose:
           self.logger.debug("closing channel_id: %s" % channel.channel_id)
           try:    channel.close()
           except: pass
       try:    self.connection.close()
       except: pass
       self.toclose    = []
       self.connection = None

   def connect(self):

       if self.sleeping != None :
          self.asleep = self.sleeping()

       if self.asleep : return

       while True:
          try:
               # connect
               self.logger.debug("Connecting %s %s (ssl %s)" % (self.host,self.user,self.ssl) )
               host = self.host
               if self.port   != None : host = host + ':%s' % self.port
               self.logger.debug("%s://%s:%s@%s%s ssl=%s" % (self.protocol,self.user,self.password,host,self.vhost,self.ssl))
               self.connection = amqp.Connection(host, userid=self.user, password=self.password, \
                                                 virtual_host=self.vhost,ssl=self.ssl)
               self.channel    = self.new_channel()
               self.logger.debug("Connected ")
               for func in self.rebuilds:
                   func()
               break
          except:
               (stype, svalue, tb) = sys.exc_info()
               self.logger.error("AMQP Sender cannot connect to: %s" % self.host)
               self.logger.error("Type=%s, Value=%s" % (stype, svalue))
               if not self.loop : sys.exit(1)
               self.logger.error("Sleeping 5 seconds ...")
               time.sleep(5)

   def new_channel(self):
       channel = self.connection.channel()
       self.toclose.append(channel)
       return channel

   def reconnect(self):
       self.close()
       self.connect()

   def set_credentials(self,protocol,user,password,host,port,vhost):
       self.protocol = protocol
       self.user     = user
       self.password = password
       self.host     = host
       self.port     = port
       self.vhost    = vhost

       if self.protocol == 'amqps' : self.ssl = True

   def set_url(self,url):
       self.protocol = url.scheme
       self.user     = url.username
       self.password = url.password
       self.host     = url.hostname
       self.port     = url.port
       self.vhost    = url.path

       if self.protocol == 'amqps' : self.ssl = True


# ==========
# Consumer
# ==========

class Consumer:

   def __init__(self,hostconnect):

      self.hc       = hostconnect
      self.logger   = self.hc.logger
      self.prefetch = 0

      self.exchange_type = 'topic'

      self.hc.add_build(self.build)

   def add_prefetch(self,prefetch):
       self.prefetch = prefetch

   def build(self):
       self.logger.debug("building consumer")
       self.channel = self.hc.new_channel()
       if self.prefetch != 0 :
          prefetch_size = 0      # dont care
          a_global      = False  # only apply here
          self.channel.basic_qos(prefetch_size,self.prefetch,a_global)
       
   def ack(self,msg):
       self.logger.debug("--------------> ACK")
       self.logger.debug("--------------> %s" % msg.delivery_tag )
       self.channel.basic_ack(msg.delivery_tag)

   def consume(self,queuename):

       msg = None

       if not self.hc.asleep :
              try :
                     msg = self.channel.basic_get(queuename)
              except :
                     (stype, value, tb) = sys.exc_info()
                     self.logger.error("Type: %s, Value: %s" % (stype, value))
                     if self.hc.loop :
                        self.hc.reconnect()
                        self.logger.info("consume resume ok")
                        if not self.hc.asleep : msg = self.consume(queuename)
       else:
              time.sleep(5)

       if msg == None : time.sleep(0.01)
       if msg != None : self.logger.debug("--------------> GOT")

       return msg

# ==========
# Exchange 
# ==========

class Exchange:

   def __init__(self,hostconnect,name,durable=False):
       self.hc     = hostconnect
       self.logger = self.hc.logger
       self.name   = name
       self.durable= durable
       self.exchange_type = 'topic'
       self.hc.add_build(self.build)

   def build(self):
       self.logger.debug("building exchange %s" % self.name)
       if self.name[:4] == 'amq.' : return
       self.hc.channel.exchange_declare(self.name, self.exchange_type, auto_delete=False,durable=self.durable)

# ==========
# Publisher
# ==========

class Publisher:

   def __init__(self,hostconnect):
       self.hc     = hostconnect
       self.logger = self.hc.logger
       self.hc.add_build(self.build)

   def build(self):
       self.logger.debug("building publisher")
       self.channel = self.hc.new_channel()
       self.channel.tx_select()
       
   def publish(self,exchange_name,exchange_key,message,headers):
       try :
              msg = amqp.Message(message, content_type= 'text/plain',application_headers=headers)
              self.channel.basic_publish(msg, exchange_name, exchange_key )
              self.channel.tx_commit()
              return True
       except :
              if self.hc.loop :
                 (stype, value, tb) = sys.exc_info()
                 self.logger.error("Type: %s, Value: %s" % (stype, value))
                 self.logger.error("Sleeping 5 seconds ... and reconnecting")
                 time.sleep(5)
                 self.hc.reconnect()
                 if self.hc.asleep : return False
                 return self.publish(exchange_name,exchange_key,message,headers)
              else:
                 (etype, evalue, tb) = sys.exc_info()
                 self.logger.error("Type: %s, Value: %s" %  (etype, evalue))
                 self.logger.error("could not publish %s %s %s %s" % (exchange_name,exchange_key,message,headers))
                 return False


# ==========
# Queue
# ==========

class Queue:

   def __init__(self,hc,qname,auto_delete=False,durable=False):

       self.hc          = hc
       self.logger      = self.hc.logger
       self.name        = qname
       self.qname       = qname
       self.auto_delete = False
       self.durable     = durable

       self.expire      = 0
       self.message_ttl = 0

       self.bindings    = []

       self.hc.add_build(self.build)

   def add_binding(self,exchange_name,exchange_key):
       self.bindings.append( (exchange_name,exchange_key) )

   def add_expire(self, expire):
       self.expire = expire

   def add_message_ttl(self, message_ttl):
       self.message_ttl = message_ttl

   def bind(self, exchange_name,exchange_key):
       self.channel.queue_bind(self.qname, exchange_name, exchange_key )

   def build(self):
       self.logger.debug("building queue %s" % self.name)
       self.channel = self.hc.new_channel()

       # queue arguments
       args = {}
       if self.expire > 0 :
          args   = {'x-expires' : self.expire }
       if self.message_ttl > 0 :
          args   = {'x-message-ttl' : self.message_ttl }

       # create queue
       self.qname, msg_count, consumer_count = \
       self.channel.queue_declare( self.name,
                                   passive=False, durable=self.durable, exclusive=False,
                                   auto_delete=self.auto_delete,
                                   nowait=False,
                                   arguments= args )

       # queue bindings
       for exchange_name,exchange_key in self.bindings:
           self.bind(exchange_name, exchange_key )

def file_insert( msg ) :

    # file must exists
    if not os.path.isfile(msg.url.path):
       fp = open(msg.url.path,'w')
       fp.close

    fp = open(msg.url.path,'r+b')
    if msg.partflg == 'i' : fp.seek(msg.offset,0)

    ok = file_write_length(fp, msg )

    fp.close()

    return ok

# when inserting, anything that goes wrong means that
# another process is working with this part_file
# so errors are ignored silently 

def file_insert_part(msg,part_file):
    try :
             # file disappeared ...
             # probably inserted by another process in parallel
             if not os.path.isfile(part_file): return False

             # file with wrong size
             # probably being written now by another process in parallel

             lstat    = os.stat(part_file)
             fsiz     = lstat[stat.ST_SIZE] 
             if fsiz != msg.length : return False

             # proceed with insertion

             fp = open(part_file,'rb')
             ft = open(msg.target_file,'r+b')
             ft.seek(msg.offset,0)

             # no worry with length, read all of part_file
             i  = 0
             while i<msg.length :
                   buf = fp.read(msg.bufsize)
                   ft.write(buf)
                   i  += len(buf)

             ft.close()
             fp.close()


             # remove inserted part file

             try    : os.unlink(part_file)
             except : pass

    # oops something went wrong

    except :
             msg.logger.debug("did not insert %s " % part_file)
             return False

    # success: log insertion

    msg.code    = 201
    msg.message = 'Inserted'
    msg.log_info()

    # publish now, if needed, that it is inserted

    if msg.amqp_pub == None : return True

    msg.set_topic_url('v02.post',msg.target_url)
    msg.set_notice(msg.target_url,msg.time)
    msg.rename  = None
    msg.code    = 201
    msg.message = 'Published'
    msg.publish()

    return True

def file_link( msg ) :

    try    : os.unlink(msg.local_file)
    except : pass
    try    : os.link(msg.url.path,msg.local_file)
    except : return False

    msg.code    = 201
    msg.message = 'Linked'
    msg.log_info()

    return True

def file_process( msg ) :

    # try link if no inserts

    if msg.partflg == '1' or \
       (msg.partflg == 'p' and  msg.in_partfile) :
       ok = file_link(msg)
       if ok : return ok

    try :
             ok = file_insert(msg)
             if ok : return ok

    except : pass

    msg.code    = 499
    msg.message = 'Not Copied'
    msg.log_error()

    return False

# when ever a part file is processed (inserted or written in part_file)
# this module is called to try inserting any part_file left

def file_reassemble(msg):

    # target file does not exit yet

    if not os.path.isfile(msg.target_file) :
       msg.logger.debug("insert_from_parts: target_file not found %s" % msg.target_file)
       return

    # check target file size and pick starting part from that

    lstat   = os.stat(msg.target_file)
    fsiz    = lstat[stat.ST_SIZE] 
    i       = int(fsiz /msg.chunksize)

    msg.logger.debug("verify ingestion : block = %d of %d" % (i,msg.block_count))
       
    while i < msg.block_count:

          # setting block i in message

          msg.current_block = i
          partstr = '%s,%d,%d,%d,%d' %\
                    ('i',msg.chunksize,msg.block_count,msg.remainder,msg.current_block)
          msg.set_parts_str(partstr)
          msg.set_suffix()

          # set part file

          part_file = msg.target_file + msg.suffix
          if not os.path.isfile(part_file) :
             msg.logger.debug("part file %s not found, stop insertion" % part_file)
             # break and not return because we want to check the lastchunk processing
             break

          # check for insertion (size may have changed)

          lstat   = os.stat(msg.target_file)
          fsiz    = lstat[stat.ST_SIZE] 
          if msg.offset > fsiz :
             msg.logger.debug("part file %s no ready for insertion (fsiz %d, offset %d)" % (part_file,fsiz,msg.offset))
             return


          # insertion attempt... should work unless there is some race condition

          ok = file_insert_part(msg,part_file)
          # break and not return because we want to check the lastchunk processing
          if not ok : break


          i = i + 1

    # out of the look... 
    # check if file needs to be truncated
    file_truncate(msg)

# write exact length

def file_write_length(req,msg):
    # file should exists
    if not os.path.isfile(msg.local_file) :
       fp = open(msg.local_file,'w')
       fp.close()

    # file open read/modify binary
    fp = open(msg.local_file,'r+b')
    if msg.local_offset != 0 : fp.seek(msg.local_offset,0)

    nc = int(msg.length/msg.bufsize)
    r  =     msg.length%msg.bufsize

    # read/write bufsize "nc" times
    i  = 0
    while i < nc :
          chunk = req.read(msg.bufsize)
          fp.write(chunk)
          i = i + 1

    # remaining
    if r > 0 :
       chunk = req.read(r)
       fp.write(chunk)

    fp.close()

    msg.code    = 201
    msg.message = 'Copied'
    msg.log_info()

    return True

def file_truncate(msg):

    # will do this when processing the last chunk
    # whenever that is
    if not msg.lastchunk : return

    try :
             lstat   = os.stat(msg.target_file)
             fsiz    = lstat[stat.ST_SIZE] 

             if fsiz > msg.filesize :
                fp = open(msg.target_file,'r+b')
                fp.truncate(msg.filesize)
                fp.close()

                msg.set_topic_url('v02.post',msg.target_url)
                msg.set_notice(msg.target_url,msg.time)
                msg.rename  = None
                msg.code    = 205
                msg.message = 'Reset Content :truncated'
                msg.log_info()

    except : pass


# ===================================
# Checksum class
# ===================================

class Checksum:
      def __init__(self):
          self.checksum = self.checksum_d

      def from_list(self,flgs):
          self.checksum = self.checksum_d
          if   flgs == 'd' :
             self.checksum = self.checksum_d
          elif flgs == 'n' :
             self.checksum = self.checksum_n
          elif flgs == '0' :
             self.checksum = self.checksum_0
          else :
             exec(compile(open(flgs).read(), flgs, 'exec'))

      # checksum_0 = checksum for flag 0

      def checksum_0(self, filepath, offset=0, length=0 ):
          return '0'

      # checksum_d = checksum for flag d

      def checksum_d(self, filepath, offset=0, length=0 ):
          f = open(filepath,'rb')
          if offset != 0 : f.seek(offset,0)
          if length != 0 : data = f.read(length)
          else:            data = f.read()
          f.close()
          return md5(data).hexdigest()

      # checksum_n = checksum for flag n

      def checksum_n( self, filepath, offset=0, length=0 ):
          filename = os.path.basename(filepath)
          return md5(bytes(filename,'utf-8')).hexdigest()

# ===================================
# chunk size from a string value
# ===================================

def chunksize_from_str(str_value):
    factor = 1
    if str_value[-1] in 'bB'   : str_value = str_value[:-1]
    if str_value[-1] in 'kK'   : factor = 1024
    if str_value[-1] in 'mM'   : factor = 1024 * 1024
    if str_value[-1] in 'gG'   : factor = 1024 * 1024 * 1024
    if str_value[-1] in 'tT'   : factor = 1024 * 1024 * 1024 * 1024
    if str_value[-1].isalpha() : str_value = str_value[:-1]
    chunksize = int(str_value) * factor

    return chunksize

class Chunk:

    def __init__(self, chunksize, chksum, filepath ):

        self.chunksize     = chunksize
        self.chksum        = chksum
        self.filepath      = filepath

        lstat              = os.stat(filepath)
        self.fsiz          = lstat[stat.ST_SIZE]

        self.chunksize     = self.fsiz
        self.block_count   = 1
        self.remainder     = 0

        if chunksize != 0 and chunksize < self.fsiz :
           self.chunksize   = chunksize
           self.block_count = int(self.fsiz / self.chunksize)
           self.remainder   = self.fsiz % self.chunksize
           if self.remainder > 0 : self.block_count = self.block_count + 1

    def get_Nblock(self):
           return self.block_count

    def get(self,current_block):

        if current_block >= self.block_count : return None

        if self.block_count == 1 :
           data_sum  = self.chksum(self.filepath,0,self.fsiz)
           return (self.fsiz, 1, 0, 0, data_sum)

        data_sum = self.chksum(self.filepath,current_block*self.chunksize,self.chunksize)

        return (self.chunksize, self.block_count, self.remainder, current_block, data_sum) 


# ===================================
# Seek info
# ===================================

def Seekinfo( chunksize, block_count, remainder, current_block ):
    chunksize     = int(chunksize)
    block_count   = int(block_count)
    remainder     = int(remainder)
    current_block = int(current_block)

    offset = current_block * chunksize
    length = chunksize
    if remainder > 0 and current_block == block_count-1 : length = remainder

    fsiz   = block_count * chunksize
    if remainder > 0 : fsiz = fsiz - chunksize + remainder

    return offset,length,fsiz

class dd_message():

    def __init__(self,logger):
        self.logger        = logger
        self.amqp_log      = None
        self.amqp_pub      = None
        self.exchange      = None
        self.exchange_pub  = None
        self.topic         = None
        self.notice        = None
        self.headers       = {}

        self.flow          = None
        self.message       = None
        self.partstr       = None
        self.rename        = None
        self.source        = None
        self.sumstr        = None
        self.sumflg        = None

        self.part_ext      = 'Part'

        self.chkclass      = Checksum()

        self.bufsize       = 10 * 1024 * 1024

        self.inplace       = True

        self.user          = None

        self.host          = socket.getfqdn()

    def change_partflg(self, partflg ):
        self.partflg       =  partflg 
        self.partstr       = '%s,%d,%d,%d,%d' %\
                             (partflg,self.chunksize,self.block_count,self.remainder,self.current_block)

    def checksum_match(self):
        if not os.path.isfile(self.local_file) : return False
        if self.sumflg in ['0','n']            : return False

        self.compute_local_checksum()

        return self.local_checksum == self.checksum

    def compute_local_checksum(self):
        self.local_checksum = self.compute_chksum(self.local_file,self.local_offset,self.length)

    def from_amqplib(self, msg ):

        self.start_timer()

        #self.logger.debug("attributes= %s" % vars(msg))
        self.exchange  = msg.delivery_info['exchange']
        self.topic     = msg.delivery_info['routing_key']
        self.headers   = msg.properties['application_headers']
        self.notice    = msg.body

        if type(msg.body) == bytes :
           self.notice = msg.body.decode("utf-8")
  
        self.flow      = None
        self.message   = None
        self.partstr   = None
        self.rename    = None
        self.source    = None
        self.sumstr    = None

        token        = self.topic.split('.')
        self.version = token[0]

        if self.version == 'v00' :
           self.parse_v00_post()

        if self.version == 'v02' :
           self.parse_v02_post()

    def get_elapse(self):
        return time.time()-self.tbegin

    def log_amqp(self):
        self.log_topic    = self.topic.replace('.post.','.log.')
        self.log_notice   = "%s %d %s %s %f" % \
                       (self.notice,self.code,self.host,self.user,self.get_elapse())
        self.headers['message'] = self.message
        self.set_headers()

        if self.amqp_log != None :
           log_exchange = 'xlog'
           self.amqp_log.publish(log_exchange,self.log_topic,self.log_notice,self.headers)


    def log_error(self):
        self.log_amqp()

        if self.logger   != None :
           self.logger.error("%d %s : %s %s %s" % (self.code,self.message,self.log_topic,self.log_notice,self.hdrstr))

        del self.headers['message']

    def log_info(self):
        self.log_amqp()

        if self.logger   != None :
           self.set_headers()
           self.logger.info("%d %s : %s %s %s" % (self.code,self.message,self.log_topic,self.log_notice,self.hdrstr))

        del self.headers['message']

    def parse_v00_post(self):
        token             = self.topic.split('.')
        # v00             = token[0]
        # dd              = token[1]
        # notify          = token[2]
        self.version      = 'v02'
        self.mtype        = 'post'
        self.topic_prefix = 'v02.post'
        self.subtopic     = '.'.join(token[3:])
        self.topic        = self.topic_prefix + '.' + self.subtopic

        token        = self.notice.split(' ')
        url          = urllib.parse.urlparse(token[2]+token[3])
        self.set_notice(url)
        
        self.checksum = token[0]
        self.filesize = int(token[1])

        self.filename = self.headers['filename']

        self.hdrstr   = ''

        self.source   = 'metpx'
        self.headers['source'] = self.source
        self.hdrstr  += '%s=%s ' % ('source',self.source)

        self.partstr = '1,%d,1,0,0' % self.filesize
        self.headers['parts'] = self.partstr
        self.hdrstr  += '%s=%s ' % ('parts',self.partstr)

        self.sumstr  = 'd,%s' % self.checksum
        self.headers['sum'] = self.sumstr
        self.hdrstr  += '%s=%s ' % ('sum',self.sumstr)

        self.flow    = None
        self.rename  = None
        self.message = None

        self.suffix = ''
        
        self.set_parts_str(self.partstr)
        self.set_sum_str(self.sumstr)
        self.set_suffix()

    def parse_v02_post(self):

        token         = self.topic.split('.')
        self.version  = token[0]
        self.mtype    = token[1]
        self.topic_prefix = '.'.join(token[:2])
        self.subtopic     = '.'.join(token[3:])

        token        = self.notice.split(' ')
        self.time    = token[0]
        self.url     = urllib.parse.urlparse(token[1]+token[2])
        self.path    = token[2]

        self.hdrstr  = ''

        self.source  = None
        if 'source'  in self.headers :
           self.source   = self.headers['source']
           self.hdrstr  += '%s=%s ' % ('source',self.source)

        self.partstr = None
        if 'parts'   in self.headers :
           self.partstr  = self.headers['parts']
           self.hdrstr  += '%s=%s ' % ('parts',self.partstr)

        self.sumstr  = None
        if 'sum'     in self.headers :
           self.sumstr   = self.headers['sum']
           self.hdrstr  += '%s=%s ' % ('sum',self.sumstr)

        self.flow    = None
        if 'flow'    in self.headers :
           self.flow     = self.headers['flow']
           self.hdrstr  += '%s=%s ' % ('flow',self.flow)

        self.rename  = None
        if 'rename'  in self.headers :
           self.rename   = self.headers['rename']
           self.hdrstr  += '%s=%s ' % ('rename',self.rename)

        self.message = None
        if 'message' in self.headers :
           self.message  = self.headers['message']
           self.hdrstr  += '%s=%s ' % ('message',self.message)

        self.suffix = ''

        self.set_parts_str(self.partstr)
        self.set_sum_str(self.sumstr)
        self.set_suffix()
        self.set_msg_time()

    def part_suffix(self):
        return '.%d.%d.%d.%d.%s.%s' %\
               (self.chunksize,self.block_count,self.remainder,self.current_block,self.sumflg,self.part_ext)

    def publish(self):
        if self.amqp_pub != None :
           self.amqp_pub.publish(self.exchange_pub,self.topic,self.notice,self.headers)
        self.log_info()

    def set_exchange(self,name):
        self.exchange = name

    def set_flow(self,flow=None):
        self.flow   = flow

    def set_headers(self):
        self.headers = {}
        self.hdrstr  = ''

        if self.source  != None :
           self.headers['source']  = self.source
           self.hdrstr  += '%s=%s ' % ('source',self.source)

        if self.partstr != None :
           self.headers['parts']   = self.partstr
           self.hdrstr  += '%s=%s ' % ('parts',self.partstr)

        if self.sumstr  != None :
           self.headers['sum']     = self.sumstr
           self.hdrstr  += '%s=%s ' % ('sum',self.sumstr)

        if self.flow    != None :
           self.headers['flow']    = self.flow
           self.hdrstr  += '%s=%s ' % ('flow',self.flow)

        if self.rename  != None :
           self.headers['rename']  = self.rename
           self.hdrstr  += '%s=%s ' % ('rename',self.rename)

        if self.message != None :
           self.headers['message'] = self.message
           self.hdrstr  += '%s=%s ' % ('message',self.message)

        # added for v00 compatibility (old version of dd_subscribe)
        # can be taken off when v02 will be fully deployed and end user uses new dd_subscribe
        self.headers['filename'] = os.path.basename(self.url.path).split(':')[0]


    # Once we know the local file we want to use
    # we can have a few flavor of it

    def set_local(self,inplace,local_file,local_url):

        self.inplace       = inplace

        self.local_file    = local_file
        self.local_url     = local_url
        self.local_offset  = 0
        self.in_partfile   = False
        self.local_checksum= None

        # file to file

        if self.partflg == '1' : return

        # part file never inserted

        if not self.inplace :

           self.in_partfile = True

           # part file to part file

           if self.partflg == 'p' : return

           # file inserts to part file

           if self.partflg == 'i' :
              self.local_file = local_file + self.suffix
              self.local_url  = urllib.parse.urlparse( local_url.geturl() + self.suffix )
              return

        
        # part file inserted

        if self.inplace :

           # part file inserts to file (maybe in file, maybe in part file)

           if self.partflg == 'p' :
              self.target_file  = local_file.replace(self.suffix,'')
              self.target_url   = urllib.parse.urlparse( local_url.geturl().replace(self.suffix,''))
              part_file    = local_file
              part_url     = local_url

        
           # file insert inserts into file (maybe in file, maybe in part file)

           if self.partflg == 'i' :
              self.target_file  = local_file
              self.target_url   = local_url
              part_file    = local_file + self.suffix
              part_url     = urllib.parse.urlparse( local_url.geturl() + self.suffix )

           # default setting : redirect to temporary part file

           self.local_file  = part_file
           self.local_url   = part_url
           self.in_partfile = True
        
           # try to make this message a file insert

           # file exists
           if os.path.isfile(self.target_file) :
              self.logger.debug("local_file exists")
              lstat   = os.stat(self.target_file)
              fsiz    = lstat[stat.ST_SIZE] 

              self.logger.debug("offset vs fsiz %d %d" % (self.offset,fsiz ))
              # part/insert can be inserted 
              if self.offset <= fsiz :
                 self.logger.debug("insert")
                 self.local_file   = self.target_file
                 self.local_url    = self.target_url
                 self.local_offset = self.offset
                 self.in_partfile  = False
                 return

              # in temporary part file
              self.logger.debug("exist but no insert")
              return


           # file does not exists but first part/insert ... write directly to local_file
           elif self.current_block == 0 :
              self.logger.debug("not exist but first block")
              self.local_file  = self.target_file
              self.local_url   = self.target_url
              self.in_partfile = False
              return

           # file does not exists any other part/insert ... put in temporary part_file
           else :
              self.logger.debug("not exist and not first block")
              self.in_partfile = True
              return
                 
        # unknow conditions

        self.logger.error("bad unknown conditions")
        return

    def set_msg_time(self):
        parts       = self.time.split('.')
        ts          = time.strptime(parts[0], "%Y%m%d%H%M%S" )
        ep_msg      = calendar.timegm(ts)
        self.tbegin = ep_msg + int(parts[1]) / 1000.0

    def set_notice(self,url,time=None):
        self.time = time
        if time  == None : self.set_time()
        self.url    = url
        path        = url.path
        urlstr      = url.geturl()
        static_part = urlstr.replace(path,'')
        self.notice = '%s %s %s' % (self.time,static_part,path)

    def set_parts(self,partflg='1',chunksize=0, block_count=1, remainder=0, current_block=0):
        self.partflg       =  partflg 
        self.chunksize     =  chunksize
        self.block_count   =  block_count
        self.remainder     =  remainder
        self.current_block =  current_block
        self.partstr       =  None
        if partflg         == None : return
        self.partstr       = '%s,%d,%d,%d,%d' %\
                             (partflg,chunksize,block_count,remainder,current_block)
        self.lastchunk     = current_block == block_count-1

    def set_parts_str(self,partstr):

        self.partflg = None
        self.partstr = partstr

        if self.partstr == None : return

        token        = self.partstr.split(',')
        self.partflg = token[0]

        self.chunksize     = int(token[1])
        self.block_count   = 1
        self.remainder     = 0
        self.current_block = 0
        self.lastchunk     = True

        self.offset        = 0
        self.length        = self.chunksize

        self.filesize      = self.chunksize

        if self.partflg == '1' : return

        self.block_count   = int(token[2])
        self.remainder     = int(token[3])
        self.current_block = int(token[4])
        self.lastchunk     = self.current_block == self.block_count-1

        self.offset        = self.current_block * self.chunksize

        self.filesize      = self.block_count * self.chunksize

        if self.remainder  > 0 :
           self.filesize  += self.remainder   - self.chunksize
           if self.lastchunk : self.length    = self.remainder

    def set_rename(self,rename):
        self.rename = rename

    def set_source(self,source):
        self.source = source

    def set_sum(self,sumflg='d',checksum=0):
        self.sumflg    =  sumflg
        self.checksum  =  checksum
        self.sumstr    =  None
        if self.sumflg == None : return
        self.sumstr    = '%s,%s' % (sumflg,checksum)

    def set_sum_str(self,sumstr):
        self.sumflg  = None
        self.sumstr  = sumstr
        if sumstr == None : return

        token        = self.sumstr.split(',')
        self.sumflg  = token[0]
        self.checksum= token[1]

        # file was removed
        if self.sumflg == 'R' : return

        self.chkclass.from_list(self.sumflg)
        self.compute_chksum = self.chkclass.checksum

    def set_suffix(self):
        if self.partstr == None : return
        if self.sumstr  == None or self.sumflg == 'R' : return
        self.suffix = self.part_suffix()

    def set_time(self):
        msec = '.%d' % (int(round(time.time() * 1000)) %1000)
        now  = time.strftime("%Y%m%d%H%M%S",time.gmtime()) + msec
        self.time = now

    def set_topic_url(self,topic_prefix,url):
        self.topic_prefix = topic_prefix
        self.url          = url
        path              = url.path.strip('/')
        self.subtopic     = path.replace('/','.')
        self.topic        = '%s.%s' % (topic_prefix,self.subtopic)
        self.topic        = self.topic.replace('..','.')

    def set_topic_usr(self,topic_prefix,subtopic):
        self.topic_prefix = topic_prefix
        self.subtopic     = subtopic
        self.topic        = '%s.%s' % (topic_prefix,self.subtopic)
        self.topic        = self.topic.replace('..','.')

    def start_timer(self):
        self.tbegin = time.time()

    def verify_part_suffix(self,filepath):
        filename = os.path.basename(filepath)
        token    = filename.split('.')

        try :  
                 self.suffix = '.' + '.'.join(token[-6:])
                 if token[-1] != self.part_ext : return False,'not right extension'

                 self.chunksize     = int(token[-6])
                 self.block_count   = int(token[-5])
                 self.remainder     = int(token[-4])
                 self.current_block = int(token[-3])
                 self.sumflg        = token[-2]

                 if self.current_block >= self.block_count : return False,'current block wrong'
                 if self.remainder     >= self.chunksize   : return False,'remainder too big'

                 self.length    = self.chunksize
                 self.lastchunk = self.current_block == self.block_count-1
                 self.filesize  = self.block_count * self.chunksize
                 if self.remainder  > 0 :
                    self.filesize  += self.remainder - self.chunksize
                    if self.lastchunk : self.length  = self.remainder

                 lstat     = os.stat(filepath)
                 fsiz      = lstat[stat.ST_SIZE] 

                 if fsiz  != self.length : return False,'wrong file size'

                 self.chkclass.from_list(self.sumflg)
                 self.compute_chksum = self.chkclass.checksum

                 self.checksum  = self.compute_chksum(filepath,0,fsiz)

        except :
                 (stype, svalue, tb) = sys.exc_info()
                 self.logger.error("Type: %s, Value: %s" % (stype, svalue))
                 return False,'incorrect extension'

        return True,'ok'

#============================================================

class ConsumerX(object):

    def __init__(self,config,logger):
        self.logger     = logger

        self.connected  = False

        self.connection  = None
        self.channel     = None
        self.log_channel = None
        self.ssl        = False

        self.queue      = None
        self.durable    = False
        self.expire     = None

        self.notify_only = False
        self.discard = False
        
        self.config = config
        self.name   = config

        self.amqp_log = None
        self.myinit()

    def close(self):
       self.hc.close()
       self.connected = False

    def connect(self):

        self.hc = None

        self.hc = HostConnect( logger = self.logger )
        self.hc.set_url(self.broker)
        self.hc.connect()

        self.consumer = Consumer(self.hc)
        self.consumer.add_prefetch(1)
        self.consumer.build()

        #should not declare exchange just use them
        #ex = Exchange(self.hc,self.exchange)
        #ex.build()

        self.msg_queue = Queue(self.hc,self.queue,durable=self.durable)
        if self.expire != None :
           self.msg_queue.add_expire(self.expire)
        if self.message_ttl != None :
           self.msg_queue.add_message_ttl(self.message_ttl)


        if self.ssl:
           sproto='amqps'
        else:
           sproto='amqp'

        for k in self.exchange_key :
           self.logger.info('Binding queue %s with key %s to exchange %s on broker %s://%s@%s%s', 
		self.queue, k, self.exchange, self.broker.scheme, self.broker.username, self.broker.hostname,self.broker.path )
           self.msg_queue.add_binding(self.exchange, k )

        self.msg_queue.build()

        if self.log_back :
           self.amqp_log = Publisher(self.hc)
           self.amqp_log.build()
           #xlog exchange should exists...
           #end users will not configure/create ii
           #xlog = Exchange(self.hc,'xlog')
           #xlog.build()

    def reconnect(self):
        self.close()
        self.connect()

    def run(self):

        if self.discard:
           self.inplace   = False
           self.overwrite = True
           self.log_back  = False

        if self.notify_only :
           self.log_back  = False

        self.logger.info("AMQP  broker(%s) user(%s) vhost(%s)" % (self.broker.hostname,self.broker.username,self.broker.path) )
        for k in self.exchange_key :
            self.logger.info("AMQP  input :    exchange(%s) topic(%s)" % (self.exchange,k) )
        if self.log_back :
            self.logger.info("AMQP  output:    exchange(%s) topic(%s)\n" % ('xlog','v02.log.#') )


        if not self.connected : self.connect()

        if not hasattr(self,'msg') :
           self.msg = dd_message(self.logger)

        self.msg.user         = self.amqp_user
        self.msg.amqp_log     = self.amqp_log
        self.msg.logger       = self.logger


        while True :

             try  :
                  raw_msg = self.consumer.consume(self.queue)
                  if raw_msg == None : continue

                  self.logger.debug("Received msg  %s" % vars(raw_msg))

                  # make use it as a dd_message

                  try :
                           self.msg.from_amqplib(raw_msg)
                  except :
                           self.msg.code    = 417
                           self.msg.message = "Expectation Failed : sumflg or partflg"
                           self.msg.log_error()
                           self.consumer.ack(raw_msg)
                           continue

                  # process message

                  processed = self.treat_message()

                  if processed :
                     self.consumer.ack(raw_msg)
             except (KeyboardInterrupt, SystemExit):
                 break                 
             except :
                 (type, value, tb) = sys.exc_info()
                 self.logger.error("Type: %s, Value: %s,  ..." % (type, value))
                 
    def myinit(self):
        self.bufsize       = 128 * 1024     # read/write buffer size

        self.protocol      = 'amqp'
        self.host          = 'dd.weather.gc.ca'
        self.port          = 5672
        self.amqp_user     = 'anonymous'
        self.amqp_passwd   = 'anonymous'
        self.vhost         = '/'

        if self.port == 5672 :
           self.broker     =  urllib.parse.urlparse('%s://%s:%s@%s%s'% \
                              (self.protocol,self.amqp_user,self.amqp_passwd,self.host,self.vhost))
        else:
           self.broker     =  urllib.parse.urlparse('%s://%s:%s@%s:%d%s'%\
                              (self.protocol,self.amqp_user,self.amqp_passwd,self.host,self.port,self.vhost))

        self.masks         = []             # All the masks (accept and reject)
        self.lock          = '.tmp'         # file send with extension .tmp for lock

        self.exchange      = 'xpublic'
        self.exchange_type = 'topic'
        self.exchange_key  = []

        self.topic_prefix  = 'v02.post'

        self.http_user     = None
        self.http_passwd   = None

        self.flatten       = '/'
        self.mirror        = False

        self.strip         = 0
        self.overwrite     = True
        self.inplace       = True
        self.log_back      = True
        self.message_ttl   = None
        
        self.readConfig()

        # if not set in config : automated queue name saved in queuefile

        if self.queue == None :
           self.queuefile = ''
           parts = self.config.split(os.sep)
           if len(parts) != 1 :  self.queuefile = os.sep.join(parts[:-1]) + os.sep

           fnp   = parts[-1].split('.')
           if fnp[0][0] != '.' : fnp[0] = '.' + fnp[0]
           self.queuefile = self.queuefile + '.'.join(fnp[:-1]) + '.queue'

           self.queuename()

    def queuename(self) :

        self.queue  = 'cmc'
        if sys.version[:1] >= '3' :
           self.queue += '.' + str(random.randint(0,100000000)).zfill(8)
           self.queue += '.' + str(random.randint(0,100000000)).zfill(8)
        else :
           self.queue += '.' + string.zfill(random.randint(0,100000000),8)
           self.queue += '.' + string.zfill(random.randint(0,100000000),8)

        if os.path.isfile(self.queuefile) :
           f = open(self.queuefile)
           self.queue = f.read()
           f.close()
        else :
           f = open(self.queuefile,'w')
           f.write(self.queue)
           f.close()


    # url path will be replicated under odir (the directory given in config file)
    def mirrorpath(self, odir, url ):
        nodir = odir

        start = 3
        if self.strip > 0 :
           start = start + self.strip
           if start > len(parts)-1 : return nodir
        
        try :
              parts = url.split("/")
              for d in parts[start:-1] :
                  nodir = nodir + os.sep + d
                  if os.path.isdir(nodir) : continue
                  os.mkdir(nodir)
        except :
              self.logger.error("could not create or use directory %s" % nodir)
              return None

        return nodir

    # process individual url notification
    def treat_message(self):

        url = self.msg.url.geturl()

        # root directory where the product will be put
        odir = self.getMatchingMask(url)

        # no root directory for this url means url not selected
        if not odir : return True
        
        # notify_only mode : print out received message
        if self.notify_only :
           self.logger.info("%s %s" % (self.msg.notice,self.msg.hdrstr))
           return True
        # log what is selected
        else :
           self.logger.info("Received topic   %s" % self.msg.topic)
           self.logger.info("Received notice  %s" % self.msg.notice)
           self.logger.info("Received headers %s" % self.msg.headers)

        # remove flag not supported
        if self.msg.sumflg == 'R' :
           self.logger.info("Remove flag not supported")
           return True
        
        # root directory should exists
        if not os.path.isdir(odir) :
           self.logger.error("directory %s does not exist" % odir)
           return False

        # mirror mode True
        # means extend root directory with url directory
        nodir = odir
        if self.mirror :
           nodir = self.mirrorpath(odir,url)
           if nodir == None : return False

        # filename setting
        parts = url.split("/")
        fname = parts[-1]

        # flatten mode True
        # means use url to create filename by replacing "/" for self.flatten character
        if self.flatten != '/' :
           start = 3
           if self.strip > 0 :
              start = start + self.strip
              if start > len(parts)-1 :
                 fname = parts[-1]
              else :
                 fname = self.flatten.join(parts[start:])

        # setting filepath and temporary filepath
        opath = nodir + os.sep + fname

        # setting local_file and URL and how the file is renamed

        self.msg.set_local(self.inplace,opath,urllib.parse.urlparse('file:'+opath))
        self.msg.headers['rename'] = opath

        # if local_file has same checksum nothing to do

        if not self.overwrite and self.msg.checksum_match() :
           self.msg.code    = 304
           self.msg.message = 'not modified'
           self.msg.log_info()

           # a part unmodified can make a difference
           if self.inplace and self.msg.in_partfile :
              file_reassemble(self.msg)

           file_truncate(self.msg)
           return True

        # download the file

        self.download(self.msg,url,self.http_user,self.http_passwd)
        return True

    def house_keeping(self):

        # Delayed insertion
        # try reassemble the file, conditions may have changed since writing

        if self.inplace and self.msg.in_partfile :
           self.msg.code    = 307
           self.msg.message = 'Temporary Redirect'
           self.msg.log_info()
           file_reassemble(self.msg)
           return True

        # announcing the download or insert

        if self.msg.partflg != '1' :
           if self.inplace : self.msg.change_partflg('i')
           else            : self.msg.change_partflg('p')

        #self.msg.set_topic_url('v02.post',self.msg.local_url)
        #self.msg.set_notice(self.msg.local_url,self.msg.time)
        self.msg.code    = 201
        self.msg.message = 'Downloaded'
        self.msg.log_info()
              
        # if we inserted a part in file ... try reassemble

        if self.inplace and self.msg.partflg != '1' :
           file_reassemble(self.msg)

        return True

    def download(self,msg,url,user=None,password=None) :

        if sys.version[:1] >= '3' :
           import urllib.request, urllib.error
           urllib_request = urllib.request
           urllib_error   = urllib.error
        else :
           import urllib2
           urllib_request = urllib2
           urllib_error   = urllib2

        # get the file, in case of error it will try three times.
        nb_try = 0
        while nb_try < 3:
            nb_try = nb_try + 1
            try :
                # create a password manager                
                if user != None :                          
                    # Add the username and password.
                    password_mgr = urllib_request.HTTPPasswordMgrWithDefaultRealm()
                    password_mgr.add_password(None, url, user, password)
                    handler = urllib_request.HTTPBasicAuthHandler(password_mgr)
                        
                    # create "opener" (OpenerDirector instance)
                    opener = urllib_request.build_opener(handler)
    
                    # use the opener to fetch a URL
                    opener.open(url)
    
                    # Install the opener.
                    # Now all calls to urllib2.urlopen use our opener.
                    urllib_request.install_opener(opener)

                # set a byte range to pull from remote file

                req   = urllib_request.Request(url)

                if msg.partflg == 'i' :
                   str_range = 'bytes=%d-%d'%(msg.offset,msg.offset+msg.length-1)
                   req.headers['Range'] = str_range
                   
                response = urllib_request.urlopen(req)

                self.write_to_file(response,msg)                    

                self.house_keeping()
                #self.logger.info('Download successful: %s', url)  
                
                #option to discard file
                if self.discard: 
                    try:
                        os.unlink(self.msg.local_file)
                        self.logger.info('Discard %s', self.msg.local_file)
                    except:
                        self.logger.error('Unable to discard %s', self.msg.local_file)
                else:
                    self.logger.info('Local file created: %s', self.msg.local_file)
                    
                break
            except (KeyboardInterrupt, SystemExit):
                 break                     
            except TimeoutException:                    
                self.logger.error('Download failed: %s', url)                    
                self.logger.error('Connection timeout')
            except urllib_error.HTTPError as e:
                self.logger.error('Download failed: %s', url)                    
                self.logger.error('Server couldn\'t fulfill the request. Error code: %s, %s', e.code, e.reason)
            except urllib_error.URLError as e:
                self.logger.error('Download failed: %s', url)                                    
                self.logger.error('Failed to reach server. Reason: %s', e.reason)            
            except:
                self.logger.error('Download failed: %s', url )
                self.logger.error('Uexpected error')              
                
            self.logger.info('Retry in 3 seconds...')
            time.sleep(3)

    def write_to_file(self,req,msg) :

        # no locking if insert
        if msg.partflg != '1' and not msg.in_partfile :
           local_file = msg.local_file
        else :
           local_file = msg.local_file + self.lock
           if self.lock == '.' :
              token = msg.local_file.split(os.sep)
              local_file = os.sep.join(token[:-1]) + os.sep + '.' + token[-1]
              self.logger.debug("lock file = %s" % local_file)
           
        # download/write
        if not os.path.isfile(local_file) :
           fp = open(local_file,'w')
           fp.close

        fp = open(local_file,'r+b')
        if msg.local_offset != 0 : fp.seek(msg.local_offset,0)

        while True:
          chunk = req.read(msg.bufsize)
          if not chunk : break
          fp.write(chunk)

        fp.close()

        # unlock
        if local_file != msg.local_file :
           os.rename(local_file,msg.local_file)

    def readConfig(self):
        currentDir = '.'
        currentFileOption = 'NONE' 
        self.readConfigFile(self.config,currentDir,currentFileOption)

        if self.masks == [] :
            print("Error 5: accept is missing from config file")
            print("Try `dd_subscribe --help' for more information.")
            sys.exit(3)

        if self.exchange_key == [] :
            print("Error 6: exchange_key is missing from config file")
            print("Try `dd_subscribe --help' for more information.")
            sys.exit(3)


    def readConfigFile(self,filePath,currentDir,currentFileOption):
        
        def isTrue(s):
            if  s == 'True' or s == 'true' or s == 'yes' or s == 'on' or \
                s == 'Yes' or s == 'YES' or s == 'TRUE' or s == 'ON' or \
                s == '1' or  s == 'On' :
                return True
            else:
                return False

        try:
            config = open(filePath, 'r')
        except:
            (type, value, tb) = sys.exc_info()
            print("Type: %s, Value: %s" % (type, value))
            return 

        for line in config.readlines():
            words = line.split()
            if (len(words) >= 2 and not re.compile('^[ \t]*#').search(line)):
                try:
                    if   words[0] == 'accept':
                         cmask       = re.compile(words[1])
                         cFileOption = currentFileOption
                         if len(words) > 2: cFileOption = words[2]
                         self.masks.append((words[1], currentDir, cFileOption, cmask, True))
                    elif words[0] == 'reject':
                         cmask = re.compile(words[1])
                         self.masks.append((words[1], currentDir, currentFileOption, cmask, False))
                    elif words[0] == 'broker': 
                         self.broker = urllib.parse.urlparse(words[1])
                         ok, self.broker = self.validate_amqp_url(self.broker)
                         if not ok :
                            self.logger.error("broker is incorrect (%s)" % words[1])
                            continue
                         self.protocol = self.broker.scheme
                         self.host     = self.broker.hostname
                         if self.broker.port     != None : self.port        = int(self.broker.port)
                         if self.broker.username != None : self.amqp_user   = self.broker.username
                         if self.broker.password != None : self.amqp_passwd = self.broker.password
                         if self.broker.path     != None : self.vhost       = self.broker.path
                         self.logger.debug("%s:%s@%s:%d%s"%(self.amqp_user,self.amqp_passwd,self.host,self.port,self.vhost))
                         self.logger.debug("%s"%self.broker.geturl())

                    elif words[0] == 'directory': currentDir = words[1]
                    elif words[0] == 'protocol': self.protocol = words[1]
                    elif words[0] == 'host':
                         self.host = words[1]
                         if self.port == 5672 :
                            self.broker     =  urllib.parse.urlparse('%s://%s:%s@%s%s'% \
                              (self.protocol,self.amqp_user,self.amqp_passwd,self.host,self.vhost))
                         else :
                            self.broker     =  urllib.parse.urlparse('%s://%s:%s@%s:%d%s'%\
                              (self.protocol,self.amqp_user,self.amqp_passwd,self.host,self.port,self.vhost))
                         self.logger.warning("host %s" % words[1])
                         self.logger.warning("host option deprecated (but still working)")
                         self.logger.warning("use this instead :")
                         self.logger.warning("broker %s\n" % self.broker.geturl())
                         self.logger.debug("%s:%s@%s:%d%s"%(self.amqp_user,self.amqp_passwd,self.host,self.port,self.vhost))
                         self.logger.debug("%s"%self.broker.geturl())
                    elif words[0] == 'port':
                         self.port = int(words[1])
                         if self.port == 5672 :
                            self.broker     =  urllib.parse.urlparse('%s://%s:%s@%s%s'% \
                              (self.protocol,self.amqp_user,self.amqp_passwd,self.host,self.vhost))
                         else :
                            self.broker     =  urllib.parse.urlparse('%s://%s:%s@%s:%d%s'%\
                              (self.protocol,self.amqp_user,self.amqp_passwd,self.host,self.port,self.vhost))
                         self.logger.warning("port %s" % words[1])
                         self.logger.warning("port option deprecated (but still working)")
                         self.logger.warning("use this instead :")
                         self.logger.warning("broker %s" % self.broker.geturl())
                         self.logger.debug("%s:%s@%s:%d%s"%(self.amqp_user,self.amqp_passwd,self.host,self.port,self.vhost))
                         self.logger.debug("%s"%self.broker.geturl())
                    elif words[0] == 'amqp-user':
                         self.amqp_user = words[1]
                         if self.port == 5672 :
                            self.broker     =  urllib.parse.urlparse('%s://%s:%s@%s%s'% \
                              (self.protocol,self.amqp_user,self.amqp_passwd,self.host,self.vhost))
                         else :
                            self.broker     =  urllib.parse.urlparse('%s://%s:%s@%s:%d%s'%\
                              (self.protocol,self.amqp_user,self.amqp_passwd,self.host,self.port,self.vhost))
                         self.logger.debug("%s:%s@%s:%d%s"%(self.amqp_user,self.amqp_passwd,self.host,self.port,self.vhost))
                         self.logger.debug("%s"%self.broker.geturl())
                    elif words[0] == 'amqp-password':
                         self.amqp_passwd = words[1]
                         if self.port == 5672 :
                            self.broker     =  urllib.parse.urlparse('%s://%s:%s@%s%s'% \
                              (self.protocol,self.amqp_user,self.amqp_passwd,self.host,self.vhost))
                         else :
                            self.broker     =  urllib.parse.urlparse('%s://%s:%s@%s:%d%s'%\
                              (self.protocol,self.amqp_user,self.amqp_passwd,self.host,self.port,self.vhost))
                         self.logger.debug("%s:%s@%s:%d%s"%(self.amqp_user,self.amqp_passwd,self.host,self.port,self.vhost))
                         self.logger.debug("%s"%self.broker.geturl())
                    elif words[0] == 'vhost':
                         self.logger.warning("vhost option deprecated (but still working)")
                         self.logger.warning("use  option broker (default amqp://anonymous:anonymous@dd.weather.gc.ca:5672/' ")
                         self.vhost = words[1]
                         if self.port == 5672 :
                            self.broker     =  urllib.parse.urlparse('%s://%s:%s@%s%s'%\
                              (self.protocol,self.amqp_user,self.amqp_passwd,self.host,self.vhost))
                         else :
                            self.broker     =  urllib.parse.urlparse('%s://%s:%s@%s:%d%s'%\
                              (self.protocol,self.amqp_user,self.amqp_passwd,self.host,self.port,self.vhost))
                         self.logger.debug("%s:%s@%s:%d%s"%(self.amqp_user,self.amqp_passwd,self.host,self.port,self.vhost))
                         self.logger.debug("%s"%self.broker.geturl())
                    elif words[0] == 'lock': self.lock = words[1]

                    elif words[0] == 'exchange': self.exchange = words[1]
                    elif words[0] == 'exchange_type': 
                         if words[1] in ['fanout','direct','topic','headers'] :
                            self.exchange_type = words[1]
                         else :
                            self.logger.error("Problem with exchange_type %s" % words[1])

                    elif words[0] == 'exchange_key':
                         self.logger.warning("exchange_key %s" % words[1])
                         self.logger.warning("exchange_key option deprecated (but still working)")
                         self.logger.warning("use this instead :")
                         subtopic = words[1].replace('v00.dd.notify.','')
                         subtopic = subtopic.replace('v02.post.','')
                         self.logger.warning("subtopic %s\n" % subtopic)
                         self.exchange_key.append(self.topic_prefix+'.'+subtopic)

                    elif words[0] == 'topic':        self.exchange_key.append(words[1])
                    elif words[0] == 'topic_prefix': self.topic_prefix = words[1]
                    elif words[0] == 'subtopic':     self.exchange_key.append(self.topic_prefix+'.'+words[1])
                    elif words[0] == 'http-user': self.http_user = words[1]
                    elif words[0] == 'http-password': self.http_passwd = words[1]
                    elif words[0] == 'mirror': self.mirror = isTrue(words[1])
                    elif words[0] == 'flatten': self.flatten = words[1]

                    elif words[0] == 'durable': self.durable = isTrue(words[1])
                    elif words[0] == 'expire': self.expire = int(words[1]) * 60 * 1000
                    elif words[0] == 'strip': self.strip = int(words[1])
                    elif words[0] == 'overwrite': self.overwrite = isTrue(words[1])
                    #default is file is reassemble at dd_subscribe level
                    #elif words[0] == 'inplace': self.inplace = isTrue(words[1])
                    elif words[0] == 'log_back': self.log_back = isTrue(words[1])
                    elif words[0] == 'queue': self.queue = words[1] 
                    elif words[0] == 'message-ttl': self.message_ttl = int(words[1]) * 60 * 1000
                    else:
                        self.logger.error("Unknown configuration directive %s in %s" % (words[0], self.config))
                        print("Unknown configuration directive %s in %s" % (words[0], self.config))
                except:
                    self.logger.error("Problem with this line (%s) in configuration file of client %s" % (words, self.name))
        config.close()
    
    def getMatchingMask(self, filename): 
        for mask in self.masks:
            if mask[3].match(filename) != None :
               if mask[4] : return mask[1]
               return None
        return None

    def validate_amqp_url(self,url):
        if not url.scheme in ['amqp','amqps'] :
           return False,url

        user = url.username
        pasw = url.password
        path = url.path

        rebuild = False
        if user == None  :
           user = self.amqp_user
           rebuild = True
        if pasw == None  :
           pasw = self.amqp_passwd
           rebuild = True
        if path == ''  :
           path = '/'
           rebuild = True

        if rebuild :
           urls = '%s://%s:%s@%s%s' % (url.scheme,user,pasw,url.netloc,path)
           url  = urllib.parse.urlparse(urls)

        return True,url


def help():     
    #print chr(27)+'[1m'+'Script'+chr(27)+'[0m'
    print("\nUsage: ")
    print("\ndd_subscribe [-n|--no-download] [-d|--download-and-discard] [-l|--log-dir] <config-file>")
    print("\nConnect to an AMQP broker to subscribe to timely file update announcements.\n")
    print("Examples:\n")    
    print("dd_subscribe subscribe.conf  # download files and display log in stdout")
    print("dd_subscribe -d subscribe.conf  # discard files after downloaded and display log in stout")
    print("dd_subscribe -l /tmp subscribe.conf  # download files,write log file in directory /tmp")
    print("dd_subscribe -n subscribe.conf  # get notice only, no file downloaded and display log in stout\n")
    print("subscribe.conf file settings, MANDATORY ones must be set for a valid configuration:\n" +
          "\nAMQP broker connection:\n" +
          "\tbroker amqp{s}://<user>:<pw>@<brokerhost>[:port]/<vhost>\n" +
	  "\t\t(default: amqp://anonymous:anonymous@dd.weather.gc.ca/ ) \n" +
          "\t\tbroken out: protocol,amqp-user,amqp-password,host,port,vhost\n" +
          "\nAMQP Queue settings:\n" +
          "\tdurable       <boolean>      (default: False)\n" +
          "\texchange      <name>         (default: xpublic)\n" +
          "\texpire        <minutes>      (default: None)\n" +
          "\tmessage-ttl   <minutes>      (default: None)\n" +
          "\tqueue         <name>         (default: None)\n" +
          "\tsubtopic      <amqp pattern> (MANDATORY)\n" +
          "\t\t  <amqp pattern> = <directory>.<directory>.<directory>...\n" +
          "\t\t\t* single directory wildcard (matches one directory)\n" +
          "\t\t\t# wildcard (matches rest)\n" +
          "\ttopic_prefix  <amqp pattern> (invariant prefix, currently v00.dd.notify)\n" +
          "\nHTTP Settings:\n" +
          "\thttp-password <pw> (default: None)\n" +
          "\thttp-user   <user> (default: None)\n" +
          "\nLocal File Delivery settings:\n" +
          "\taccept    <regexp pattern> (MANDATORY)\n" +
          "\tdirectory <path>           (default: .)\n" +
          "\tflatten   <boolean>        (default: false)\n" +
          "\tlock      <.string>        (default: .tmp)\n" +
          "\tmirror    <boolean>        (default: false)\n" +
          "\treject    <regexp pattern> (optional)\n" +
          "\tstrip    <count> (number of directories to remove from beginning.)\n" +
	  "" )

def signal_handler(signal, frame):
    print('You pressed Ctrl+C!')
    #print('Resume in 5 seconds...')
    #time.sleep(5)
    sys.exit()
    #os.kill(os.getpid(),9)

def verify_version():    
    python_version = (2,6,0)
    if sys.version_info < python_version :
        sys.stderr.write("Python version higher than 2.6.0 required.\n")
        exit(1)
        
    amqplib_version = '1.0.0'   
    if amqp.connection.LIBRARY_PROPERTIES['library_version'] < amqplib_version:
        sys.stderr.write("Amqplib version %s or higher required.\n" % amqplib_version)        
        exit(1)
    
def main():

    ldir = None
    notice_only = False
    discard = False
    config = None
    
    #get options arguments
    try:
      opts, args = getopt.getopt(sys.argv[1:],'hl:dtn',['help','log-dir=','download-and-discard','no-download'])
    except getopt.GetoptError as err:    
      print("Error 1: %s" %err)
      print("Try `dd_subscribe --help' for more information.")
      sys.exit(2)                    
    
    #validate options
    if opts == [] and args == []:
      help()  
      sys.exit(1)
    for o, a in opts:
      if o in ('-h','--help'):
        help()
        sys.exit(1)
      elif o in ('-n','--no-download'):
        notice_only = True        
      elif o in ('-l','--log-dir'):
        ldir = a       
        if not os.path.exists(ldir) :
          print("Error 2: specified logging directory does not exist.")
          print("Try `dd_subscribe --help' for more information.")
          sys.exit(2)
      elif o in ('-d','--download-and-discard'):
        discard = True        
        
    #validate arguments
    if len(args) == 1:
      config = args[0]
      if not os.path.exists(config) :
         print("Error 3: configuration file does not exist.")
         sys.exit(2)
    elif len(args) == 0:
      help()  
      sys.exit(1)
    else:      
      print("Error 4: too many arguments given: %s." %' '.join(args))
      print("Try `dd_subscribe --help' for more information.")
      sys.exit(2)            
             

    # logging to stdout
    LOG_FORMAT = ('%(asctime)s [%(levelname)s] %(message)s')

    if ldir == None :
       LOGGER = logging.getLogger(__name__)
       logging.basicConfig(level=logging.INFO, format=LOG_FORMAT)

    # user wants to logging in a directory/file
    else :       
       fn     = config.replace(".conf","")
       lfn    = fn + "_%s" % os.getpid() + ".log"
       lfile  = ldir + os.sep + lfn

       # Standard error is redirected in the log
       sys.stderr = open(lfile, 'a')

       # python logging
       LOGGER = None
       fmt    = logging.Formatter( LOG_FORMAT )
       hdlr   = logging.handlers.TimedRotatingFileHandler(lfile, when='midnight', interval=1, backupCount=5) 
       hdlr.setFormatter(fmt)
       LOGGER = logging.getLogger(lfn)
       LOGGER.setLevel(logging.INFO)
       LOGGER.addHandler(hdlr)

    # instanciate consumer

    consumer = ConsumerX(config,LOGGER)
    consumer.notify_only = notice_only
    consumer.discard = discard
    
    consumer.run()
    """
    while True:
         try:
                consumer.run()
         except :
                (type, value, tb) = sys.exc_info()
                LOGGER.error("Type: %s, Value: %s,  ..." % (type, value))
                time.sleep(10)
                pass
                
    """
    consumer.close()


if __name__ == '__main__':
    verify_version()
    signal.signal(signal.SIGINT, signal_handler)
    main()

