#!/usr/bin/python3

import builtins,getopt,hashlib,os,socket,stat,sys,time
from   hashlib import md5
import amqplib.client_0_8 as amqp
import logging,logging.handlers
import socket
import paramiko
from   paramiko import *
import urllib.request, urllib.error

# ==========
# HostConnect
# ==========

class HostConnect:

   def __init__(self, host, user, passwd, ssl = False, logger = None, loop = True):

       self.asleep     = False
       self.loop       = loop

       self.connection = None
       self.channel    = None
       self.ssl        = ssl

       self.logger     = logger

       self.host       = host
       self.user       = user
       self.passwd     = passwd

       self.rebuilds   = []

       self.sleeping   = None

   def add_build(self,func):
       self.rebuilds.append(func)

   def add_sleeping(self,func):
       self.sleeping = func
       
   def close(self):
       try:    self.channel.close()
       except: pass
       try:    self.connection.close()
       except: pass

       self.connection = None
       self.channel    = None

   def connect(self):

       if self.sleeping != None :
          self.asleep = self.sleeping()

       if self.asleep : return

       while True:
          try:
               # connect
               self.logger.debug("Connecting %s %s " % (self.host,self.user) )
               self.connection = amqp.Connection(self.host, userid=self.user, password=self.passwd, ssl=self.ssl)
               self.channel    = self.connection.channel()
               self.logger.debug("Connected ")
               for func in self.rebuilds:
                   func()
               break
          except:
               if not self.loop : sys.exit(1)
               (stype, svalue, tb) = sys.exc_info()
               self.logger.error("AMQP Sender cannot connected to: %s" % self.host)
               self.logger.error("Type=%s, Value=%s" % (stype, svalue))
               self.logger.error("Sleeping 5 seconds ...")
               time.sleep(5)


   def reconnect(self):
       self.close()
       self.connect()

# ==========
# Consumer
# ==========

class Consumer:

   def __init__(self,hostconnect):

      self.hc       = hostconnect
      self.logger   = self.hc.logger
      self.prefetch = 0

      self.exchange_type = 'topic'

      self.hc.add_build(self.build)

   def add_prefetch(self,prefetch):
       self.prefetch = prefetch

   def build(self):
       self.logger.debug("building consumer")
       if self.prefetch != 0 :
          prefetch_size = 0      # dont care
          a_global      = False  # only apply here
          self.channel.basic_qos(prefetch_size,self.prefetch,a_global)

   def ack(self,msg):
       self.logger.debug("--------------> ACK")
       self.logger.debug("--------------> %s" % msg.delivery_tag )
       self.hc.channel.basic_ack(msg.delivery_tag)

   def consume(self,queuename):

       msg = None

       if not self.hc.asleep :
              try :
                     msg = self.hc.channel.basic_get(queuename)
              except :
                     if self.hc.loop :
                        self.hc.reconnect()
                        self.logger.info("consume resume ok")
                        if not self.hc.asleep : msg = self.consume(queuename)
       else:
              time.sleep(5)

       if msg == None : time.sleep(0.01)
       if msg != None : self.logger.debug("--------------> GOT")

       return msg

# ==========
# Exchange 
# ==========

class Exchange:

   def __init__(self,hostconnect,name):
       self.hc     = hostconnect
       self.logger = self.hc.logger
       self.name   = name
       self.exchange_type = 'topic'
       self.hc.add_build(self.build)

   def build(self):
       self.logger.debug("building exchange %s" % self.name)
       self.hc.channel.exchange_declare(self.name, self.exchange_type, auto_delete=False)

# ==========
# Publisher
# ==========

class Publisher:

   def __init__(self,hostconnect):
       self.hc     = hostconnect
       self.logger = self.hc.logger
       self.hc.add_build(self.build)

   def build(self):
       self.logger.debug("building publisher")
       self.hc.channel.tx_select()

   def publish(self,exchange_name,exchange_key,message,filename):
       try :
              hdr = {'filename': filename }
              msg = amqp.Message(message, content_type= 'text/plain',application_headers=hdr)
              self.hc.channel.basic_publish(msg, exchange_name, exchange_key )
              self.hc.channel.tx_commit()
       except :
              time.sleep(5)
              self.hc.reconnect()
              if self.hc.asleep : return
              self.publish(exchange_name,exchange_key,message,filename)

# ==========
# Queue
# ==========

class Queue:

   def __init__(self,hc,qname,auto_delete=False):

       self.hc          = hc
       self.logger      = self.hc.logger
       self.name        = qname
       self.qname       = qname
       self.auto_delete = False

       self.expire      = 0
       self.message_ttl = 0

       self.bindings    = []

       self.hc.add_build(self.build)

   def add_binding(self,exchange_name,exchange_key):
       self.bindings.append( (exchange_name,exchange_key) )

   def add_expire(self, expire):
       self.expire = expire

   def add_message_ttl(self, message_ttl):
       self.message_ttl = message_ttl

   def bind(self, exchange_name,exchange_key):
       self.hc.channel.queue_bind(self.qname, exchange_name, exchange_key )

   def build(self):
       self.logger.debug("building queue %s" % self.name)

       # queue arguments
       args = {}
       if self.expire > 0 :
          args   = {'x-expires' : self.expire }
       if self.message_ttl > 0 :
          args   = {'x-message-ttl' : self.message_ttl }

       # create queue
       self.qname, msg_count, consumer_count = \
       self.hc.channel.queue_declare( self.name,
                                      passive=False, durable=False, exclusive=False,
                                      auto_delete=self.auto_delete,
                                      nowait=False,
                                      arguments= args )

       # queue bindings
       for exchange_name,exchange_key in self.bindings:
           self.bind(exchange_name, exchange_key )

# ===================================
# checksum of file
# ===================================

def Checksum( filepath, offset=0, length=0 ):
    f = open(filepath,'rb')
    if offset != 0 : f.seek(offset,0)
    if length != 0 : data = f.read(length)
    else:            data = f.read()
    f.close()
    return md5(data).hexdigest(),len(data)

# ===================================
# Chunk of file
# ===================================

def Chunk( chunksize, chksum, filepath ):

    factor = 1
    if chunksize[-1] in 'bB'   : chunksize = chunksize[:-1]
    if chunksize[-1] in 'kK'   : factor = 1024
    if chunksize[-1] in 'mM'   : factor = 1024 * 1024
    if chunksize[-1] in 'gG'   : factor = 1024 * 1024 * 1024
    if chunksize[-1] in 'tT'   : factor = 1024 * 1024 * 1024 * 1024
    if chunksize[-1].isalpha() : chunksize = chunksize[:-1]
    chunksize = int(chunksize) * factor

    lstat = os.stat(filepath)
    fsiz  = lstat[stat.ST_SIZE]

    if chunksize == 0 or chunksize >= fsiz :
       data_sum,l   = chksum(filepath,0,fsiz)
       return [ (fsiz, 1, 0, 0, 'd', data_sum) ]

    block_count = int(fsiz / chunksize)
    remainder   = fsiz % chunksize
    if remainder > 0 : block_count = block_count + 1

    total = block_count*chunksize
    if remainder > 0 : total = total - chunksize + remainder
    
    if fsiz != total :
       print("\n")
       print("ERROR:  bc       %d " % block_count)
       print("ERROR:  chunksiz %d " % chunksize)
       print("ERROR:  rem      %d " % remainder)
       print("ERROR:  total   %d " % ((block_count-1)*chunksize + remainder))
       print("ERROR:  blocking incorrect\n")
       sys.exit(1)
        
    i=0
    current_block=0
    parts = []
    while i<fsiz:
          data_sum,length = chksum(filepath,i,chunksize)
          parts.append( (chunksize, block_count, remainder, current_block, 'd', data_sum) )
          current_block += 1
          i = i + length

    return parts

# ===================================
# Key for exchange
# v01.dd_notify.relative_filepath
# v01.post.YYYYMMDD.user.relative_filepath
# ===================================

class Key:
      def __init__(self):
          self.version = 'v01'
          self.ktype   = 'post'
          self.day     = time.strftime("%Y%m%d",time.gmtime())
          self.user    = None
          self.lpath   = ''

      def from_key(self,key):
          self.key = key
          parts = key.split('.')
          self.version = parts[0]
          if self.version == 'v01' :
             self.ktype   = parts[1]
             self.day     = parts[2]
             self.user    = parts[3]
             self.lpath   = os.sep.join(parts[4:])

          if self.version == 'v00' :
             self.ktype = 'dd.notify'
             self.user  = None
             self.day   = None
             self.lpath = os.sep.join(parts[3:])

      def get(self):
          self.key = self.version
          self.key = self.key + '.%s' % self.ktype
          if self.version == 'v01' :
             self.key = self.key + '.%s' % self.day
             self.key = self.key + '.%s' % self.user
          self.key = self.key + '.%s' % self.lpath.replace(os.sep,'.')
          self.key = self.key.replace('..','.')
          if self.key[-1] == '.' : self.key = self.key[:-1]
          return self.key

      def set(self, user, lpath ):
          self.user  = user
          self.lpath = lpath

# ===================================
# mkdir
# ===================================

def mkdir(filepath):
    parts = filepath.split(os.sep)
    apath = ''
    for d in parts[:-1] :
        if d == '' : continue
        apath += os.sep + d
        if os.path.isdir(apath) : continue
        os.mkdir(apath,0o775)

# ==========
# Notice
# ==========

class Notice:
      def __init__(self):
          msec = '.%d' % (int(round(time.time() * 1000)) %1000)
          now  = time.strftime("%Y%m%d%H%M%S",time.gmtime()) + msec
          self.time          = now

          self.chunksize     = 0
          self.block_count   = 0
          self.remainder     = 0
          self.current_block = 0
          self.type_sum      = ''
          self.data_sum      = ''

          self.tag           = ''

          self.source        = ''
          self.lpath         = ''

          self.code          = None
          self.server        = ''
          self.user          = ''
          self.download_time = 0.0

      # get notice from its settings
      def get(self):

          self.notice = self.time   
          self.notice = self.notice + ' %d' % self.chunksize
          self.notice = self.notice + ' %d' % self.block_count
          self.notice = self.notice + ' %d' % self.remainder
          self.notice = self.notice + ' %d' % self.current_block
          self.notice = self.notice + ' %c' % self.type_sum
          self.notice = self.notice + ' %s' % self.data_sum
          self.notice = self.notice + ' %s' % self.tag
          self.notice = self.notice + ' %s' % self.source
          self.notice = self.notice + ' %s' % self.lpath

          if self.code != None :
             self.notice = self.notice + ' %s'  % self.code
             self.notice = self.notice + ' %s'  % self.server
             self.notice = self.notice + ' %s'  % self.user
             self.notice = self.notice + ' %s'  % self.download_time
          
          return self.notice

      # set notice from its string
      def from_notice(self,notice):

          parts = notice.split(' ')

          self.time          = parts[0]
          self.chunksize     = int(parts[1])
          self.block_count   = int(parts[2])
          self.remainder     = int(parts[3])
          self.current_block = int(parts[4])
          self.type_sum      = parts[5]
          self.data_sum      = parts[6]
          self.tag           = parts[7]

          self.source        = parts[8]
          self.lpath         = parts[9]
          self.dpath         = parts[9]

          sparts = self.dpath.split('/')
          self.dfile         = sparts[-1]

          self.url           = self.source

          if self.url[-1] == '/' :
             self.url   = self.url + self.lpath

          # log notice
          if len(parts) > 10 :
             self.code          = parts[10]
             self.server        = parts[11]
             self.user          = parts[12]
             self.download_time = parts[13]

      # set chunk info
      def set_chunk(self,chunksize,block_count,remainder,current_block,type_sum,data_sum):
          self.chunksize     = chunksize
          self.block_count   = block_count
          self.remainder     = remainder
          self.current_block = current_block
          self.type_sum      = type_sum
          self.data_sum      = data_sum

      # set log info
      def set_log(self,code,user,download_time=0.0):
          self.code          = None
          self.server        = socket.gethostname()
          self.user          = user
          self.download_time = 0.0

      # set source info
      def set_source(self,source,lpath):
          self.source = source
          self.lpath  = lpath

      # set tag info
      def set_tag(self,tag):
          self.tag           = tag

# ===================================
# Seek info
# ===================================

def Seekinfo( chunksize, block_count, remainder, current_block ):
    chunksize     = int(chunksize)
    block_count   = int(block_count)
    remainder     = int(remainder)
    current_block = int(current_block)

    offset = current_block * chunksize
    length = chunksize
    if remainder > 0 and current_block == block_count-1 : length = remainder

    fsiz   = block_count * chunksize
    if remainder > 0 : fsiz = fsiz - chunksize + remainder

    return offset,length,fsiz

# ==========
# URL
# ==========

class URL:
      def __init__(self):
         self.error    = False
         self.url      = None
         self.protocol = None
         self.host     = None
         self.port     = None
         self.user     = None
         self.password = None
         self.puphp    = None
         self.path     = None
         self.filename = None

      # get url from pieces
      def get(self):
          self.error   = False
          url          = None
          try :
                hp = self.host
                if self.port     != None : hp += ':' + self.port
                up = self.user
                if self.password != None : up += ':' + self.password
                credentials = hp
                if up != None : credentials = up + '@' + hp

                url = self.protocol + '://' + credentials + '/'
                if self.path != None : url += self.path
                self.url = url

                if self.protocol  == '' : raise error
                if self.host      == '' : raise error
                if self.port      == '' : raise error
                if self.user      == '' : raise error
                if self.password  == '' : raise error
          except:
                self.error = True

          return url

      # get url from pieces
      def get_nocredential(self):
          self.error   = False
          url          = None
          try :
                hp = self.host
                if self.port     != None : hp += ':' + self.port
                url = self.protocol + '://' + hp + '/'
                if self.path != None : url += self.path
                self.url = url

                if self.protocol  == '' : raise error
                if self.host      == '' : raise error
                if self.port      == '' : raise error
          except:
                self.error = True

          return url

      # set pieces from url
      def set(self,url):
          self.error = False
          self.url   = url
          try :
                slashes = url.split('/')
                self.protocol = slashes[0][:-1]
                credentials   = slashes[2].split('@')
                parts         = credentials[-1].split(':')
                self.host     = parts[0]
                if len(parts) == 2 : self.port = parts[-1]
                if len(credentials) == 2 :
                   parts      = credentials[0].split(':')
                   self.user  = parts[0]
                   if len(parts)    == 2  : self.password = parts[-1]
                if len(slashes) >= 4  : self.path = '/'.join(slashes[3:])
                if slashes[-1]  != '' : self.filename = slashes[-1]

                if slashes[1]     != '' : raise error
                if slashes[0][-1] != ':': raise error
                if self.protocol  == '' : raise error
                if self.host      == '' : raise error
                if self.port      == '' : raise error
                if self.user      == '' : raise error
                if self.password  == '' : raise error
          except:
                self.error = True


class dd_download(object):

    def __init__(self,logger):

        self.logger  = logger

        self.lfile   = None
        self.str_url = None
        self.url     = URL()

        self.ssh_keyfile = None

        self.bufsize  = 128 * 1024 # read/write buffer size

    def chunk_filename(self, chunksize, current_block ):
        parts = self.lfile.split(os.sep)
        fdir  = os.sep.join(parts[:-1])
        fname = parts[-1]
        chunk_fname = '.' + fname + '.%d.%d' % (chunksize, current_block )
        return fdir + os.sep + chunk_fname

    def http_download(self,lfile,offset,length,fsiz):
        url    = self.url.get_nocredential()
        user   = self.url.user
        passwd = self.url.password
        try :
                # create a password manager                
                if user != None :                          
                    # Add the username and password.
                    password_mgr = urllib.request.HTTPPasswordMgrWithDefaultRealm()
                    password_mgr.add_password(None, url,user,passwd)
                    handler = urllib.request.HTTPBasicAuthHandler(password_mgr)
                        
                    # create "opener" (OpenerDirector instance)
                    opener = urllib.request.build_opener(handler)
    
                    # use the opener to fetch a URL
                    opener.open(url)
    
                    # Install the opener.
                    # Now all calls to urllib2.urlopen use our opener.
                    urllib.request.install_opener(opener)

                # byte range if needed
                req   = urllib.request.Request(url)
                str_range = ''
                if length != 0 :
                   str_range = 'bytes=%d-%d'%(offset,offset+length-1)
                   req.headers['Range'] = str_range
                else :
                   length = fsiz
                   
                #download file
                response = urllib.request.urlopen(req)
                self.write_to_file(response,lfile,offset,length)                    

                if str_range != '' :
                   self.logger.info('Inserting: %s %s %s' % (url,lfile,str_range))  
                else :
                   self.logger.info('Downloads: %s %s' % (url,lfile))  

                return True
                
        except urllib.error.HTTPError as e:
                self.logger.error('Download failed 1: %s', url)                    
                self.logger.error('Server couldn\'t fulfill the request. Error code: %s, %s', e.code, e.reason)
        except urllib.error.URLError as e:
                self.logger.error('Download failed 2: %s', url)                                    
                self.logger.error('Failed to reach server. Reason: %s', e.reason)            
        except:
                self.logger.error('Download failed 3: %s', url )
                self.logger.error('Uexpected error')              
        return False

    def get(self, chunksize, block_count, remainder, current_block, type_sum, data_sum, from_chunk = False ):

        # setting notice

        self.dnotice.set_chunk(chunksize,block_count,remainder,current_block,type_sum,data_sum)

        # get chunk info

        r_offset,r_length,r_fsiz = Seekinfo(chunksize, block_count, remainder, current_block )

        # check if chunk update needed

        l_needs_update,l_fsiz = self.update(self.lfile, r_offset,r_length,r_fsiz, type_sum,data_sum )

        # needs to be truncated maybe

        truncated = False
        if current_block == block_count-1 :
           if r_fsiz < l_fsiz :
              self.truncate(r_fsiz)
              truncated = True

        # if not needed everything is ok

        if not l_needs_update :
           self.logger.info("Unchanged: %s" % self.lfile )
           if truncated :
              self.logger.info("Truncated: %s (%d to %d)" % (self.lfile,l_fsiz,r_fsiz) )
              self.publish()
           return True

        # should we put the chunk straight in the file

        infile = False
        if r_offset <= l_fsiz : infile = True

        # if we cannot download for now... keep chunk info
        if not infile and not from_chunk :
           cfile = self.chunk_filename( chunksize, current_block )
           f = open( cfile, 'w' )
           f.write('%d,%d,%d,%d,\'%c\',\'%s\'' % \
                  ( chunksize, block_count, remainder, current_block, type_sum, data_sum ))
           f.close()
           self.logger.info("Suspended: %s " % cfile )
           return True

        # special case download the entire file
        length = r_length
        if block_count == 1 : length = 0

        # go ahead and download in file
        downloaded = False
        if self.url.protocol == 'http' :
           downloaded = self.http_download(self.lfile,r_offset,length,r_fsiz)
        if self.url.protocol == 'sftp' :
           downloaded = self.sftp_download(self.lfile,r_offset,length,r_fsiz)

        if downloaded : self.publish()
        if truncated  : self.logger.info("Truncated: %s (%d to %d)" % (self.lfile,l_fsiz,r_fsiz) )

        if not downloaded : return False
        
        if downloaded and from_chunk :
           cfile = self.chunk_filename( chunksize, current_block )
           os.unlink(cfile)

        # process other chunk already received ?
        next_block = current_block + 1
        if next_block < block_count :
           cfile = self.chunk_filename( chunksize, next_block )
           if os.path.isfile(cfile) :
              self.logger.info("Detecting %s " % cfile )
              exec(compile('self.get(' + open(cfile).read() + ',True)\n',cfile,'exec'))

        return True

    def publish(self):

        str_key  = self.dkey.get()
        filename = os.path.basename(self.lfile)
        message  = self.dnotice.get()

        self.logger.info("%s : key      = %s" % ('xpublic',str_key))
        self.logger.info("%s : body     = %s" % ('xpublic',message) )
        self.logger.info("%s : filename = %s" % ('xpublic',filename) )

        self.pub.publish('xpublic',str_key,message,filename)

        log_key   = str_key.replace('.post.','.log.')
        message  += ' 202 ' + socket.gethostname() + ' ' + self.url.user + ' 0.0'

        self.logger.info("%s : key      = %s" % ('log',log_key))
        self.logger.info("%s : body     = %s" % ('log',message) )
        self.logger.info("%s : filename = %s" % ('log',filename) )

        self.log.publish('log',log_key,message,filename)

    def set_key(self,dkey):
        self.dkey = dkey
        
    def set_local_file(self,lfile):
        self.lfile = lfile

    def set_notice(self,dnotice):
        self.dnotice = dnotice

    def set_publish(self,pub,log):
        self.pub = pub
        self.log = log

    def set_url(self,url):
        self.str_url = url
        self.url.set(url)

    def sftp_download(self,lfile,offset,length,fsiz):
        host     = self.url.host
        port     = self.url.port
        user     = self.url.user
        passwd   = self.url.password
        ssh_keyfile = self.ssh_keyfile
        cdir     = self.url.path.replace(self.url.filename,'')
        cfile    = self.url.filename
        url      = self.url.get_nocredential()

        try :
                self.t = None
                if port == None : 
                   self.t = paramiko.Transport(host)
                else:
                   t_args = (host,port)
                   self.t = paramiko.Transport(t_args)

                if ssh_keyfile != None :
                   key=DSSKey.from_private_key_file(ssh_keyfile,password=None)
                   self.t.connect(username=user,pkey=key)
                else:
                   self.t.connect(username=user,password=passwd)

                self.sftp = paramiko.SFTP.from_transport(self.t)
                self.sftp.chdir(cdir)

                #download file
                str_range = ''
                if length == 0 :
                   self.sftp.get(cfile,lfile)
                   self.logger.info('Downloads:  %s %s' % (url,lfile))  
                else :
                   str_range = 'bytes=%d-%d'%(offset,offset+length-1)
                   response  = self.sftp.file(cfile,'rb',self.bufsize)
                   if offset != 0 : response.seek(offset,0)
                   self.write_to_file(response,lfile,offset,length)                    
                   self.logger.info('Inserting: %s %s %s' % (url,lfile,str_range))  

                try    : self.sftp.close()
                except : pass
                try    : self.t.close()
                except : pass

                return True
                
        except:
                (stype, value, tb) = sys.exc_info()
                self.logger.error("Download failed %s. Type: %s, Value: %s" % (self.url.get_nocredential(), stype ,value))

        return False
  
    def truncate(self,r_siz):
        fp = open(self.lfile,'r+b')
        fp.truncate(r_siz)
        fp.close()

    def update(self, lfile, offset, length, fsiz, type_sum, data_sum ):
        lfsiz  = 0

        if not os.path.isfile(lfile) : return True,lfsiz

        lstat  = os.stat(lfile)
        lfsiz  = lstat[stat.ST_SIZE]

        echunk = offset + length - 1
        if echunk >= lfsiz : return True,lfsiz

        ldata_sum,l = Checksum(lfile,offset,length)
        if ldata_sum != data_sum : return True,lfsiz
   
        return False,lfsiz
                
    def write_to_file(self,req,lfile,offset,length) :
        # file should exists
        if not os.path.isfile(lfile) :
           fp = open(lfile,'w')
           fp.close()

        # file open read/modify binary
        fp = open(lfile,'r+b')
        if offset != 0 : fp.seek(offset,0)

        nc = int(length/self.bufsize)
        r  = length % self.bufsize

        # loop on bufsize if needed
        i  = 0
        while i < nc :
              chunk = req.read(self.bufsize)
              if len(chunk) != self.bufsize :
                 self.logger.error('length %d and bufsize = %d' % (length,self.bufsize))
              fp.write(chunk)
              i = i + 1

        # remaining
        if r > 0 :
           chunk = req.read(r)
           if len(chunk) != r :
              self.logger.error('length %d and remainder = %d' % (length,r))
           fp.write(chunk)

        fp.close()

# ===================================
# help
# ===================================

def help(logger):
    logger.info("Usage: dd_sara [-h] [-v script] source-url exchange key ldir destination-url")

# ===================================
# default validation: notification always ok
# ===================================

def validate_ok( body, logger ):
    valid = True

    logger.debug("validate_ok")

    return valid

class Validator():
      def __init__(self):
          pass

validator         = Validator()
validator.vscript = validate_ok

# ===================================
# MAIN
# ===================================

def main():

    LOG_FORMAT = ('%(asctime)s [%(levelname)s] %(message)s')
    logger     = logging.getLogger(__name__)
    logging.basicConfig(level=logging.INFO, format=LOG_FORMAT)

    #get options arguments
    try:   opts, args = getopt.getopt(sys.argv[1:],'hv:',['help','validation_script'])
    except getopt.GetoptError as err:    
           logger.error("%s" % err )      
           logger.info("Try `dd_sara --help' for more information.")
           sys.exit(1)                    

    #validate options
    if opts == [] and args == []:
      help(logger)  
      sys.exit(2)

    for opt, value in opts:
        if opt in ('-h','--help'):
             help(logger)
             sys.exit(0)
        elif opt in ('-v','--validation_script'):
             try    :
                      exec(compile(open(value).read(), value, 'exec'))
             except : 
                      logger.error("Problem validation_script %s" % value )
                      sys.exit(1)

    if len(args) != 5 :
       help(logger)
       sys.exit(3)
        
    #validate source url
    source = URL()
    source.set(args[0])
    if source.protocol != 'amqp' or source.user == None or \
       source.password == None   or source.error :
       logger.error("source url %s " % args[0] )
       sys.exit(4)

    #
    # exchange name
    #

    exchange_name  = args[1]
    exchange_user  = exchange_name.replace('sx_','')
    exchange_key   = args[2]
    if exchange_key[-3:] != '.#' : exchange_key += '.#'
    ldir           = args[3]
    destination = URL()
    destination.set(args[4])
    if destination.error :
       logger.error("destination url %s " % args[4] )
       sys.exit(4)

    # =============
    # consumer part
    # =============

    # consumer connection

    hc_con = HostConnect( source.host,source.user,source.password,logger=logger)
    hc_con.connect()

    # consumer

    consumer = Consumer(hc_con)
    consumer.build()

    # consumer exchange : make sure it exists

    ex = Exchange(hc_con,exchange_name)
    ex.build()

    # consumer queue

    name  = 'cmc.dd_sara.' + exchange_name + '.' + exchange_key
    queue = Queue(hc_con,name)
    queue.add_binding(exchange_name,exchange_key)
    queue.build()

    # ====================
    # log publisher part 
    # ====================

    hc_log = HostConnect( source.host,source.user,source.password,logger=logger)
    hc_log.connect()

    # log exchange : make sure it exists

    elog = Exchange(hc_log,'log')
    elog.build()

    # publisher
     
    log = Publisher(hc_log)
    log.build()

    # ====================
    # publisher part 
    # ====================

    hc_pub = HostConnect( source.host,source.user,source.password,logger=logger)
    hc_pub.connect()

    # log exchange : make sure it exists

    xpub = Exchange(hc_pub,'xpublic')
    xpub.build()

    # publisher
     
    pub = Publisher(hc_pub)
    pub.build()

    # download class

    download = dd_download(logger)

    #
    # loop on all message
    #
    while True :

          try  :
                 msg = consumer.consume(queue.qname)
                 if msg == None : continue

                 # restoring all info from amqp message

                 body     = msg.body
                 exchange = msg.delivery_info['exchange']
                 str_key  = msg.delivery_info['routing_key']
                 hdr      = msg.properties['application_headers']
                 filename = hdr['filename']

                 if type(body) == bytes : body = body.decode("utf-8")

                 logger.info('Receiving: %s',body)

                 # instanciate notice class from message body

                 notice      = Notice()
                 notice.from_notice(body)

                 # message validation

                 ok = validator.vscript( body, logger )

                 if notice.url[:4] != 'http' and notice.url[:4] != 'sftp' : ok = False

                 if not ok :
                    log_key = str_key.replace('.post.','.log.')
                    logger.error('Not valid: %s',body)
                    body   += ' 404 ' + socket.gethostname() + ' ' + source.user + ' 0.0'
                    log.publish('log',log_key,body,filename)
                    logger.info("Consumed")
                    consumer.ack(msg)
                    continue

                 # Target file and directory (directory created if needed)

                 today = time.strftime("%Y%m%d",time.gmtime())
                 target_file = ldir + \
                                '/' + today + \
                                '/' + exchange_name.replace('sx_','') + \
                                '/' + notice.dpath

                 target_file = target_file.replace('//','/')

                 target_dir  = target_file.replace(notice.dfile,'')
                 mkdir(target_dir)

                 # download setup

                 dkey = Key()
                 dkey.from_key(str_key)
                 dkey.lpath = notice.dpath

                 dnotice = Notice()
                 dnotice.from_notice(body)
                 dnotice.source = destination.get()
                 dnotice.lpath  = target_file.replace(ldir+'/','')

                 download.set_key(dkey)
                 download.set_notice(dnotice)
                 download.set_publish(pub,log)

                 download.set_url(notice.url)
                 download.set_local_file(target_file)
                 download.get(notice.chunksize, notice.block_count, notice.remainder, notice.current_block, notice.type_sum,notice.data_sum)

                 logger.info("Consumed")
                 consumer.ack(msg)

          except :
                 (stype, svalue, tb) = sys.exc_info()
                 logger.error("Type: %s, Value: %s,  ..." % (stype, svalue))

    hc_con.close()
    hc_log.close()
    sys.exit(0)

if __name__ == '__main__':
    main()
