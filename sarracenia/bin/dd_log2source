#!/usr/bin/python3

import amqplib.client_0_8 as amqp
import logging,logging.handlers
import getopt, os, sys, time

# ==========
# HostConnect
# ==========

class HostConnect:

   def __init__(self, host, user, passwd, ssl = False, logger = None, loop = True):

       self.asleep     = False
       self.loop       = loop

       self.connection = None
       self.channel    = None
       self.ssl        = ssl

       self.logger     = logger

       self.host       = host
       self.user       = user
       self.passwd     = passwd

       self.rebuilds   = []

       self.sleeping   = None

   def add_build(self,func):
       self.rebuilds.append(func)

   def add_sleeping(self,func):
       self.sleeping = func
       
   def close(self):
       try:    self.channel.close()
       except: pass
       try:    self.connection.close()
       except: pass

       self.connection = None
       self.channel    = None

   def connect(self):

       if self.sleeping != None :
          self.asleep = self.sleeping()

       if self.asleep : return

       while True:
          try:
               # connect
               self.logger.debug("Connecting %s %s " % (self.host,self.user) )
               self.connection = amqp.Connection(self.host, userid=self.user, password=self.passwd, ssl=self.ssl)
               self.channel    = self.connection.channel()
               self.logger.debug("Connected ")
               for func in self.rebuilds:
                   func()
               break
          except:
               if not self.loop : sys.exit(1)
               (stype, svalue, tb) = sys.exc_info()
               self.logger.error("AMQP Sender cannot connected to: %s" % self.host)
               self.logger.error("Type=%s, Value=%s" % (stype, svalue))
               self.logger.error("Sleeping 5 seconds ...")
               time.sleep(5)


   def reconnect(self):
       self.close()
       self.connect()

# ==========
# Consumer
# ==========

class Consumer:

   def __init__(self,hostconnect):

      self.hc       = hostconnect
      self.logger   = self.hc.logger
      self.prefetch = 0

      self.exchange_type = 'topic'

      self.hc.add_build(self.build)

   def add_prefetch(self,prefetch):
       self.prefetch = prefetch

   def build(self):
       self.logger.debug("building consumer")
       if self.prefetch != 0 :
          prefetch_size = 0      # dont care
          a_global      = False  # only apply here
          self.channel.basic_qos(prefetch_size,self.prefetch,a_global)

   def ack(self,msg):
       self.logger.debug("--------------> ACK")
       self.logger.debug("--------------> %s" % msg.delivery_tag )
       self.hc.channel.basic_ack(msg.delivery_tag)

   def consume(self,queuename):

       msg = None

       if not self.hc.asleep :
              try :
                     msg = self.hc.channel.basic_get(queuename)
              except :
                     if self.hc.loop :
                        self.hc.reconnect()
                        self.logger.info("consume resume ok")
                        if not self.hc.asleep : msg = self.consume(queuename)
       else:
              time.sleep(5)

       if msg == None : time.sleep(0.01)
       if msg != None : self.logger.debug("--------------> GOT")

       return msg

# ==========
# Exchange 
# ==========

class Exchange:

   def __init__(self,hostconnect,name):
       self.hc     = hostconnect
       self.logger = self.hc.logger
       self.name   = name
       self.exchange_type = 'topic'
       self.hc.add_build(self.build)

   def build(self):
       self.logger.debug("building exchange %s" % self.name)
       self.hc.channel.exchange_declare(self.name, self.exchange_type, auto_delete=False)

# ==========
# Publisher
# ==========

class Publisher:

   def __init__(self,hostconnect):
       self.hc     = hostconnect
       self.logger = self.hc.logger
       self.hc.add_build(self.build)

   def build(self):
       self.logger.debug("building publisher")
       self.hc.channel.tx_select()

   def publish(self,exchange_name,exchange_key,message,filename):
       try :
              hdr = {'filename': filename }
              msg = amqp.Message(message, content_type= 'text/plain',application_headers=hdr)
              self.hc.channel.basic_publish(msg, exchange_name, exchange_key )
              self.hc.channel.tx_commit()
       except :
              time.sleep(5)
              self.hc.reconnect()
              if self.hc.asleep : return
              self.publish(exchange_name,exchange_key,message,filename)

# ==========
# Queue
# ==========

class Queue:

   def __init__(self,hc,qname,auto_delete=False):

       self.hc          = hc
       self.logger      = self.hc.logger
       self.name        = qname
       self.qname       = qname
       self.auto_delete = False

       self.expire      = 0
       self.message_ttl = 0

       self.bindings    = []

       self.hc.add_build(self.build)

   def add_binding(self,exchange_name,exchange_key):
       self.bindings.append( (exchange_name,exchange_key) )

   def add_expire(self, expire):
       self.expire = expire

   def add_message_ttl(self, message_ttl):
       self.message_ttl = message_ttl

   def bind(self, exchange_name,exchange_key):
       self.hc.channel.queue_bind(self.qname, exchange_name, exchange_key )

   def build(self):
       self.logger.debug("building queue %s" % self.name)

       # queue arguments
       args = {}
       if self.expire > 0 :
          args   = {'x-expires' : self.expire }
       if self.message_ttl > 0 :
          args   = {'x-message-ttl' : self.message_ttl }

       # create queue
       self.qname, msg_count, consumer_count = \
       self.hc.channel.queue_declare( self.name,
                                      passive=False, durable=False, exclusive=False,
                                      auto_delete=self.auto_delete,
                                      nowait=False,
                                      arguments= args )

       # queue bindings
       for exchange_name,exchange_key in self.bindings:
           self.bind(exchange_name, exchange_key )

# ==========
# MAIN
# ==========

def help():
    print("Usage: %s [-h] [-l logdir] host user password")

def main():

    # default options

    ldir     = None
    host     = 'localhost'
    user     = 'guest'
    password = 'guest'

    # options from arguments

    try:
           opts, args = getopt.getopt(sys.argv[1:],'hl:',['help','log-dir='])
    except getopt.GetoptError as err:    
           help()
           sys.exit(2)                    
    
    #validate options
    if opts == [] and args == []:
      help()  
      sys.exit(2)

    for o, a in opts:
        if o in ('-h','--help'):
           help()
           sys.exit(0)
        elif o in ('-l','--log-dir'):
           ldir = a       
           if not os.path.exists(ldir) :
              print("Error 2: specified logging directory does not exist.")
              help()
              sys.exit(3)
        
    #validate arguments
    if len(args) == 2:
       user   = args[0]
       passwd = args[1]

    if len(args) == 3:
       host   = args[0]
       user   = args[1]
       passwd = args[2]

    if len(args) == 1 or len(args) > 3:
      help()  
      sys.exit(4)

    # logging to stdout
    LOG_FORMAT = ('%(asctime)s [%(levelname)s] %(message)s')

    print(" LDIR = %s" % ldir)
    if ldir == None :
       logger = logging.getLogger(__name__)
       logging.basicConfig(level=logging.INFO, format=LOG_FORMAT)

    # user wants to logging in a directory/file
    else :
       lfn    = "dd_log2source.log"
       lfile  = ldir + os.sep + lfn

       # Standard error is redirected in the log
       sys.stderr = open(lfile, 'a')

       # python logging
       logger = None
       fmt    = logging.Formatter( LOG_FORMAT )
       hdlr   = logging.handlers.TimedRotatingFileHandler(lfile, when='midnight', interval=1, backupCount=5) 
       hdlr.setFormatter(fmt)
       logger = logging.getLogger(lfn)
       logger.setLevel(logging.INFO)
       logger.addHandler(hdlr)

    # =========================
    # consuming log part
    # =========================

    # consuming connection

    hc_con = HostConnect(host,user,passwd,logger=logger)
    hc_con.connect()

    # will use log exchange
    e  = Exchange(hc_con,'log')
    e.build()

    # will use a log queue
    q  = Queue(hc_con,'cmc.dd_log2source')
    q.add_binding('log','v01.log.#')
    q.build()

    
    # will consume from that queue
    c = Consumer(hc_con)
    c.build()


    # =========================
    # publishing part
    # =========================

    # publishing connection

    hc_pub = HostConnect(host,user,passwd,logger=logger)
    hc_pub.connect()

    # will publish 

    p = Publisher(hc_pub)
    p.build()

    # loop on all logs entries

    while True :

          try  :
                 msg = c.consume(q.qname)
                 if msg == None : continue

                 body   = msg.body
                 parts  = body.split()
                 md5sum = parts[0]

                 hdr = msg.properties['application_headers']
                 key = msg.delivery_info['routing_key']
                 fn  = hdr['filename']

                 parts = key.split('.')
                 exchange_name = 'sx_' + parts[3]

                 logger.info(" exchange_name = %s" % exchange_name)
                 logger.info(" body = %s" % body)
                 logger.info(" key  = %s" % key)
                 p.publish(exchange_name,key,body + ' x',fn)
                 c.ack(msg)

          except :
                 (type, value, tb) = sys.exc_info()
                 logger.error("Type: %s, Value: %s,  ..." % (type, value))

    hc_con.close()
    hc_pub.close()

# =========================================

if __name__ == '__main__':
   main()

