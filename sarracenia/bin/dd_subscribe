#!/usr/bin/python

import logging, os, random, re, signal, string, sys, time
import amqplib.client_0_8 as amqp

#============================================================
# usage example
#
# python dd_subscribe.py configfile.conf

#============================================================
# logging metpx like

LOG_FORMAT = ('%(asctime)s [%(levelname)s] %(message)s')
LOGGER = logging.getLogger(__name__)

#############################################################################################
# Class AlarmTimeout

class TimeoutException(Exception):
    """Classe d'exception specialises au timeout"""
    pass

class AlarmTimeout:
      def __init__(self, message ):
          self.state   = False
          self.message = message
      def sigalarm(self, n, f):
          raise TimeoutException(self.message)
      def alarm(self, time):
          self.state = True
          signal.signal(signal.SIGALRM, self.sigalarm)
          signal.alarm(time)
      def cancel(self):
          signal.alarm(0)
          self.state = False

#============================================================

class Consumer(object):

    def __init__(self,config):
        self.connected  = False

        self.connection = None
        self.channel    = None
        self.ssl        = False

        self.notify_only = False

        self.config = config
        self.name   = config
        self.myinit()

        self.timex = AlarmTimeout('timeout reached')

    def ack(self,msg):
        # ack timeout 5 sec
        self.timex.alarm(5)
        self.channel.basic_ack(msg.delivery_tag)
        self.timex.cancel()

    def close(self):
       # timeout 5 sec for each operation
       self.timex.alarm(5)
       try:    self.channel.close()
       except: pass
       self.timex.cancel()

       self.timex.alarm(5)
       try:    self.connection.close()
       except: pass
       self.timex.cancel()

       self.connected = False

    def connect(self):
        self.connection = None
        self.channel    = None

        while True:
             # give 20 sec to connect
             self.timex.alarm(20)

             try:
                  # connect
                  LOGGER.info("AMQP connecting %s %s " % (self.host,self.amqp_user) )
                  self.connection = amqp.Connection(self.host, userid=self.amqp_user,
                                                    password=self.amqp_passwd, ssl=self.ssl)
                  self.channel    = self.connection.channel()

                  # shared queue : each pull receive 1 message (prefetch_count=1)
                  self.channel.basic_qos(prefetch_size=0,prefetch_count=1,a_global=False)

                  # queue declare and bind

                  qn,Nmsg,Nconsumer = self.channel.queue_declare( self.queue,
                                      passive=False, durable=False, exclusive=False,
                                      auto_delete=False, nowait=False)
                                      #arguments={'x-expires' : 1800000})

                  for k in self.exchange_key :
                      LOGGER.info('Binding %s to %s with %s', self.exchange, self.queue, k)
                      self.channel.queue_bind(self.queue, self.exchange, k )

                  self.timex.cancel()
                  self.connected = True
                  LOGGER.info("Connected ")

                  break
             except:
                  self.timex.cancel()
                  (type, value, tb) = sys.exc_info()
                  LOGGER.error("AMQP Sender cannot connected to: %s" % str(self.host))
                  LOGGER.error("Type: %s, Value: %s, Sleeping 5 seconds ..." % (type, value))
                  time.sleep(5)


    def consume(self):

        # give 10 sec to consume a message
        self.timex.alarm(10)

        try :
              msg = self.channel.basic_get(self.queue)
              self.timex.cancel()
        except :
              self.timex.cancel()
              msg = None
              time.sleep(5)
              self.reconnect()

        if msg == None : time.sleep(0.01)
        return msg

    def reconnect(self):
        self.close()
        self.connect()

    def run(self):

        if not self.connected : self.connect()

        while True :

             try  :
                  msg = self.consume()
                  if msg == None : continue

                  body = msg.body
                  hdr  = msg.properties['application_headers']

                  routing_key = msg.delivery_info['routing_key']
                  exchange    = msg.delivery_info['exchange']
                  filename    = hdr['filename']

                  LOGGER.debug('Received message # %s from %s: %s', msg, msg.delivery_info, body)
                  LOGGER.debug('Received exchange %s, key %s, message file %s', exchange, routing_key, filename )

                  processed = self.treat_message(exchange,routing_key,body,filename)

                  if processed :
                     self.ack(msg)

             except :
                 (type, value, tb) = sys.exc_info()
                 LOGGER.error("Type: %s, Value: %s,  ..." % (type, value))


    def myinit(self):
        self.bufsize       = 128 * 1024     # read/write buffer size

        self.host          = 'dd.weather.gc.ca'
        self.port          = '5672'
        self.amqp_user     = 'anonymous'
        self.amqp_passwd   = 'anonymous'
        self.masks         = []             # All the masks (accept and reject)
        self.lock          = '.tmp'         # file send with extension .tmp for lock

        self.exchange      = 'xpublic'
        self.exchange_type = 'topic'
        self.exchange_key  = []

        self.http_user     = None
        self.http_passwd   = None

        self.flatten       = '/'
        self.mirror        = False

        self.queuefile = ''
        parts = self.config.split(os.sep)
        if len(parts) != 1 :  self.queuefile = os.sep.join(parts[:-1]) + os.sep

        fnp   = parts[-1].split('.')
        if fnp[0][0] != '.' : fnp[0] = '.' + fnp[0]
        self.queuefile = self.queuefile + '.'.join(fnp[:-1]) + '.queue'

        self.queuename()

        self.readConfig()

    def queuename(self) :

        self.queue  = 'cmc'
        self.queue += '.' + string.zfill(random.randint(0,100000000),8)
        self.queue += '.' + string.zfill(random.randint(0,100000000),8)

        if os.path.isfile(self.queuefile) :
           f = open(self.queuefile)
           self.queue = f.read()
           f.close()
        else :
           f = open(self.queuefile,'w')
           f.write(self.queue)
           f.close()


    # url path will be replicated under odir (the directory given in config file)
    def mirrorpath(self, odir, url ):
        nodir = odir
        
        try :
              parts = url.split("/")
              for d in parts[3:-1] :
                  nodir = nodir + os.sep + d
                  if os.path.isdir(nodir) : continue
                  os.mkdir(nodir)
        except :
              LOGGER.error("could not create or use directory %s" % nodir)
              return None

        return nodir

    # process individual url notification
    def treat_message(self,exchange,routing_key,msg,filename):

        # notify_only mode : print out received message
        if self.notify_only :
           LOGGER.info("%s" % msg)
           return True

        # in operational version, routing key starts with 'v**.dd.notify'
        # in that case message is  'md5sum http://hostname/ filepath'

        url = msg
        if routing_key[0] == 'v' :
           parts = msg.split()
           url   = parts[-2] + parts[-1]

        # root directory where the product will be put
        odir = self.getMatchingMask(url)

        # no root directory for this url means url not selected
        if not odir : return True

        # root directory should exists
        if not os.path.isdir(odir) :
           LOGGER.error("directory %s does not exist" % odir)
           return False

        # mirror mode True
        # means extend root directory with url directory
        nodir = odir
        if self.mirror :
           nodir = self.mirrorpath(odir,url)
           if nodir == None : return False

        # filename setting
        parts = url.split("/")
        fname = parts[-1]

        # flatten mode True
        # means use url to create filename by replacing "/" for self.flatten character
        if self.flatten != '/' :
           fname = self.flatten.join(parts[3:])

        # setting filepath and temporary filepath
        opath = nodir + os.sep + fname
        tpath = opath + self.lock

        # we have to get the file... loop if any issues to retry
        # only on success we acknowledge the amqp message...
        while True:
              try :
                    # gives self.timeout seconds to get the product
                    self.timex.alarm(self.timeout)
                    self.wget(url,tpath,self.http_user,self.http_passwd)
                    os.rename(tpath,opath)
                    LOGGER.info('wget %s %s', url, opath)
                    self.timex.cancel()
                    break
              except TimeoutException:
                    self.timex.cancel()
                    LOGGER.error('Timeout: wget %s', url)
              except:
                    self.timex.cancel()
                    LOGGER.error('wget %s', url)
                    time.sleep(5)

        return True

    def wget(self,url,tpath,user=None,password=None) :
        import urllib2
    
        # the simplest, simply get the html source from URL
    
        if user == None :
           sock       = urllib2.urlopen(url)
           sock = urllib2.urlopen(url)
           self.write_to_file(sock,tpath)
           return tpath
    
        # a little more complicated, need to authenticate
    
        # create a password manager
        # Add the username and password.
    
        password_mgr = urllib2.HTTPPasswordMgrWithDefaultRealm()
        password_mgr.add_password(None, url, user, password )
        handler = urllib2.HTTPBasicAuthHandler(password_mgr)
    
        # create "opener" (OpenerDirector instance)
    
        opener = urllib2.build_opener(handler)
    
        # use the opener to fetch a URL
    
        opener.open(url)
    
        # Install the opener.
        # Now all calls to urllib2.urlopen use our opener.
    
        urllib2.install_opener(opener)
    
        # now  get the html source from URL
    
        sock = urllib2.urlopen(url)
        self.write_to_file(sock,tpath)

        return tpath

    def write_to_file(self,req,ofile) :
        fp = open(ofile,'w')

        while True:
            chunk = req.read(self.bufsize)
            if not chunk: break
            fp.write(chunk)

        fp.close()

    def readConfig(self):
        currentDir = '.'
        currentFileOption = 'NONE' 
        self.readConfigFile(self.config,currentDir,currentFileOption)

    def readConfigFile(self,filePath,currentDir,currentFileOption):
        
        def isTrue(s):
            if  s == 'True' or s == 'true' or s == 'yes' or s == 'on' or \
                s == 'Yes' or s == 'YES' or s == 'TRUE' or s == 'ON' or \
                s == '1' or  s == 'On' :
                return True
            else:
                return False

        try:
            config = open(filePath, 'r')
        except:
            (type, value, tb) = sys.exc_info()
            print("Type: %s, Value: %s" % (type, value))
            return 

        self.timeout = 180

        for line in config.readlines():
            words = line.split()
            if (len(words) >= 2 and not re.compile('^[ \t]*#').search(line)):
                try:
                    if   words[0] == 'accept':
                         cmask       = re.compile(words[1])
                         cFileOption = currentFileOption
                         if len(words) > 2: cFileOption = words[2]
                         self.masks.append((words[1], currentDir, cFileOption, cmask, True))
                    elif words[0] == 'reject':
                         cmask = re.compile(words[1])
                         self.masks.append((words[1], currentDir, currentFileOption, cmask, False))
                    elif words[0] == 'directory': currentDir = words[1]
                    elif words[0] == 'host': self.host = words[1]
                    elif words[0] == 'port': self.port = int(words[1])
                    elif words[0] == 'amqp-user': self.amqp_user = words[1]
                    elif words[0] == 'amqp-password': self.amqp_passwd = words[1]
                    elif words[0] == 'lock': self.lock = words[1]

                    elif words[0] == 'exchange': self.exchange = words[1]
                    elif words[0] == 'exchange_type': 
                         if words[1] in ['fanout','direct','topic','headers'] :
                            self.exchange_type = words[1]
                         else :
                            LOGGER.error("Problem with exchange_type %s" % words[1])
                    elif words[0] == 'exchange_key': self.exchange_key.append(words[1])
                    elif words[0] == 'http-user': self.http_user = words[1]
                    elif words[0] == 'http-password': self.http_passwd = words[1]
                    elif words[0] == 'mirror': self.mirror = isTrue(words[1])
                    elif words[0] == 'flatten': self.flatten = words[1]
                    elif words[0] == 'timeout': self.timeout = int(words[1])


                except:
                    LOGGER.error("Problem with this line (%s) in configuration file of client %s" % (words, self.name))
        config.close()
    
    def getMatchingMask(self, filename): 
        for mask in self.masks:
            if mask[3].match(filename) :
               if mask[4] : return mask[1]
               return None
        return None

def main():
    logging.basicConfig(level=logging.INFO, format=LOG_FORMAT)

    # should have one argument

    if len(sys.argv) == 3 :
           if sys.argv[1] != "-n" :
              LOGGER.error("1USAGE %s [-n] configuration file",sys.argv[0])
              sys.exit(1)
           config = sys.argv[2]
    else :
           if len(sys.argv) != 2 :
              LOGGER.error("2USAGE %s [-n] configuration file",sys.argv[0])
              sys.exit(1)
           config = sys.argv[1]


    if not os.path.exists(config) :
       LOGGER.error("3USAGE %s [-n] configuration file",sys.argv[0])
       sys.exit(1)

    consumer = Consumer(config)
    if sys.argv[1] == '-n' : consumer.notify_only = True

    while( True ) :
         try:
                consumer.run()
         except :
                (type, value, tb) = sys.exc_info()
                LOGGER.error("Type: %s, Value: %s,  ..." % (type, value))
                time.sleep(10)
                pass

    consumer.close()


if __name__ == '__main__':
    main()

