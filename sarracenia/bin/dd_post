#!/usr/bin/python3

import amqplib.client_0_8 as amqp
import getopt,hashlib,os,stat,sys,time

from hashlib import md5

# ===================================
# checksum of file
# ===================================

def Checksum( offset, length, filepath ):
    f = open(filepath,'rb')
    if offset != 0 : f.seek(offset,0)
    data = f.read(length)
    f.close
    return md5(data).hexdigest(),len(data)

# ===================================
# Chunk of file
# ===================================

def Chunk( chunksize, chksum, filepath ):

    factor = 1
    if chunksize[-1] in 'bB'   : chunksize = chunksize[:-1]
    if chunksize[-1] in 'kK'   : factor = 1024
    if chunksize[-1] in 'mM'   : factor = 1024 * 1024
    if chunksize[-1] in 'gG'   : factor = 1024 * 1024 * 1024
    if chunksize[-1] in 'tT'   : factor = 1024 * 1024 * 1024 * 1024
    if chunksize[-1].isalpha() : chunksize = chunksize[:-1]
    chunksize = int(chunksize) * factor

    lstat = os.stat(filepath)
    fsiz  = lstat[stat.ST_SIZE]

    if chunksize == 0 or chunksize >= fsiz :
       sum,l   = chksum(0,fsiz,filepath)
       return [ (fsiz, 1, 0, 0, 'd', sum) ]

    block_count = int(fsiz / chunksize)
    remainder   = fsiz % chunksize
    if remainder > 0 : block_count = block_count + 1

    total = block_count*chunksize
    if remainder > 0 : total = total - chunksize + remainder
    
    if fsiz != total :
       print("bc       %d " % block_count)
       print("chunksiz %d " % chunksize)
       print("rem      %d " % remainder)
       print("total   %d " % ((block_count-1)*chunksize + remainder))
       print("Error blocking incorrect")
       sys.exit(4)
        
    i=0
    current_block=0
    parts = []
    while i<fsiz:
          sum,length = chksum(i,chunksize,filepath)
          parts.append( (chunksize, block_count, remainder, current_block, 'd', sum) )
          current_block += 1
          i = i + length

    return parts
              

# ===================================
# Key for exchange
# ===================================

def Key( ntype, user, relative_filepath ):

    today = time.strftime("%Y%m%d",time.gmtime())
    fkey  = relative_filepath.replace('/','.')

    parts = []
    parts.append('v01')   # version
    parts.append(ntype)   # notification type
    #parts.append(today)   # YYYYMMDD
    parts.append(user)    # used id
    parts.append(fkey)    # relative_filepath

    exchange_key = '.'.join(parts)

    return exchange_key

# ===================================
# Notice
# ===================================

def Notice(chunk_parts, source_url, destination_url, taginfo ):

       msec = ',%d' % (int(round(time.time() * 1000)) %1000)
       now  = time.strftime("%Y%m%d%H%M%S",time.gmtime()) + msec
       chunksize, block_count, remainder, current_block, dsum, sum = chunk_parts

       parts = []
       parts.append(now)
       parts.append( "%s" % chunksize)
       parts.append( "%s" % block_count)
       parts.append( "%s" % remainder)
       parts.append( "%s" % current_block)
       parts.append(dsum)
       parts.append(sum)

       parts.append(source_url.get())
       parts.append(destination_url.path)
       if taginfo != None and taginfo != '' : parts.append(taginfo)

       notice = ' '.join(parts)
       return notice


# ===================================
# Publisher AMQP
# ===================================

class Publisher: 
   
   def __init__(self, host, user, passwd, exchange_name ):

       self.ssl           = False
       self.host          = host
       self.user          = user
       self.passwd        = passwd
       self.realm         = '/data'
       self.exchange_name = exchange_name
       self.exchange_type = 'topic'

       self.connect()

   def close(self):
       try:    self.channel.close()
       except: pass
       try:    self.connection.close()
       except: pass

   def connect(self):

       try:
              # connect
              self.connection = amqp.Connection(self.host, userid=self.user, password=self.passwd, ssl=self.ssl)
              self.channel    = self.connection.channel()

              # what kind of exchange
              # self.channel.access_request(self.realm, active=True, write=True)
              self.channel.exchange_declare(self.exchange_name, self.exchange_type, auto_delete=False)
              self.channel.tx_select()
       except:
              (stype, svalue, tb) = sys.exc_info()
              print("AMQP Sender cannot connected to: %s" % str(self.host))
              print("Type: %s, Value: %s" % (stype, svalue))
              sys.exit(1)


   def publish(self,message,exchange_key,hdr):
       try :
              msg = amqp.Message(message, content_type= 'text/plain',application_headers=hdr)
              self.channel.basic_publish(msg, self.exchange_name, exchange_key )
              self.channel.tx_commit()
       except :
              (stype, svalue, tb) = sys.exc_info()
              print("AMQP could not publish..." )
              print("Type: %s, Value: %s ..." % (stype, svalue))
              sys.exit(2)

# ===================================
# Seek info
# ===================================

def Seekinfo( chunksize, block_count, remainder, current_block ):
    chunksize     = int(chunksize)
    block_count   = int(block_count)
    remainder     = int(remainder)
    current_block = int(current_block)

    offset = current_block * chunksize
    length = chunksize
    if remainder > 0 and current_block == block_count-1 : length = remainder

    return offset,length

# ===================================
# URL joggling
# ===================================

class URL:
      def __init__(self):
         self.error    = False
         self.url      = None
         self.protocol = None
         self.host     = None
         self.port     = None
         self.user     = None
         self.password = None
         self.path     = None
         self.filename = None

      # get url from pieces
      def get(self):
          self.error   = False
          url          = None
          try :
                hp = self.host
                if self.port     != None : hp += ':' + self.port
                up = self.user
                if self.password != None : up += ':' + self.password
                credentials = hp
                if up != None : credentials = up + '@' + hp

                url = self.protocol + '://' + credentials
                if self.path != None : url = url + '/' + self.path
                self.url = url

                if self.protocol  == '' : raise error
                if self.host      == '' : raise error
                if self.port      == '' : raise error
                if self.user      == '' : raise error
                if self.password  == '' : raise error
          except:
                self.error = True

          return url

      # set pieces from url
      def set(self,url):
          self.error = False
          self.url   = url
          try :
                slashes = url.split('/')
                self.protocol = slashes[0][:-1]
                credentials   = slashes[2].split('@')
                parts         = credentials[-1].split(':')
                self.host     = parts[0]
                if len(parts) == 2 : self.port = parts[-1]
                if len(credentials) == 2 :
                   parts      = credentials[0].split(':')
                   self.user  = parts[0]
                   if len(parts)    == 2  : self.password = parts[-1]
                if len(slashes) >= 4  : self.path = '/'.join(slashes[3:])
                if slashes[-1]  != '' : self.filename = slashes[-1]

                if slashes[1]     != '' : raise error
                if slashes[0][-1] != ':': raise error
                if self.protocol  == '' : raise error
                if self.host      == '' : raise error
                if self.port      == '' : raise error
                if self.user      == '' : raise error
                if self.password  == '' : raise error
          except:
                self.error = True


# ===================================
# MAIN
# ===================================

def help():
    print("Usage: dd_post -b blocksize -w tag [basedir] <source-url> <destination-url>")
    print("default blocksize 0")
    print("default tag ''")

def main():

    chunksize = '0'
    taginfo   = None

    #get options arguments
    try:   opts, args = getopt.getopt(sys.argv[1:],'hb:w:',['help'])
    except getopt.GetoptError as err:    
           print("Error 1: %s" %err)      
           print("Try `dd_post --help' for more information.")
           sys.exit(2)                    
    
    #validate options
    if opts == [] and args == []:
      help()  
      sys.exit(1)

    for opt, value in opts:
        if opt in ('-h','--help'):
             help()
             sys.exit(0)
        elif opt in ('-b'):
             chunksize = value        
        elif opt in ('-w'):
             taginfo = value       

    if len(args) < 2 :
       help()
       sys.exit(3)
        
    #validate amqp url
    destination = URL()
    destination.set(args[-1])
    if destination.protocol != 'amqp' or destination.user == None or destination.error :
       print("Error destination url %s " % args[-1] )
       sys.exit(1)

    #validate source url
    source = URL()
    source.set(args[-2])
    if not source.protocol in ['http','sftp']             : source.error = True
    if source.protocol == 'sftp' and source.user  == None : source.error = True
    if source.path     == None   or \
       source.path     == ''     or \
       source.path[-1] == '/'       : source.error = True
    if source.error :
       print("Error source url %s " % args[-2] )
       sys.exit(2)

    #
    # check for relative path and find real filepath
    #

    filepath = source.path

    if source.protocol == 'http' or \
     ( source.protocol == 'sftp' and source.path[0] != '/' ) :
       if len(args) < 3 :
          print("Error no basedir in %s " % args )
          sys.exit(1)
       filepath = args[-3] + '/' + source.path

    #
    # verify that file exists
    #

    if not os.path.isfile(filepath):
       print("File not found %s " % filepath )
       sys.exit(1)

    #
    # fix destination path if needed
    #
    dpath = '/' + destination.user 
    if destination.path == None or destination.path == '' :
       if source.path[0] != '/' : dpath += '/'
       dpath += source.path
    else :
       if destination.path[0] != '/' : dpath += '/'
       dpath += destination.path

    if dpath[-1] == '/' :
       dpath += source.filename

    destination.path = dpath
    destination.set(destination.get())
    if destination.error :
       print("Error destination url incorrect %s " % destination.url )
       sys.exit(4)


    #
    # Chunk it if needed
    #
    parts = Chunk(chunksize,Checksum,filepath)

    #
    # publish each parts
    #

    pub = Publisher( destination.host, destination.user, \
                     destination.password, destination.user )
    for c in parts :
        key    = Key('dd_post', destination.user, source.path )
        print(" Key %s" % key )
        notice = Notice(c, source, destination, taginfo )
        print(" Notice %s" % notice )
        hdr = {'filename': destination.filename }
        print(" header %s" % hdr )

        pub.publish( notice, key, hdr )
        #chunksize, block_count, remainder, current_block, dsum, sum = c
        #print(" %d %d %d %d %s %s " % (chunksize, block_count, remainder, current_block, dsum, sum))
        #offset,length = Seekinfo( chunksize, block_count, remainder, current_block )
        #print(" %d %d " % (offset,length))


    pub.close()
    sys.exit(0)


if __name__ == '__main__':
    main()
