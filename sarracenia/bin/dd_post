#!/usr/bin/python3

import getopt,hashlib,os,random,socket,stat,sys,time
from   hashlib import md5
import amqplib.client_0_8 as amqp
import logging,logging.handlers

# ==========
# HostConnect
# ==========

class HostConnect:

   def __init__(self, host, user, passwd, ssl = False, logger = None, loop = True):

       self.asleep     = False
       self.loop       = loop

       self.connection = None
       self.channel    = None
       self.ssl        = ssl

       self.logger     = logger

       self.host       = host
       self.user       = user
       self.passwd     = passwd

       self.rebuilds   = []

       self.sleeping   = None

   def add_build(self,func):
       self.rebuilds.append(func)

   def add_sleeping(self,func):
       self.sleeping = func
       
   def close(self):
       try:    self.channel.close()
       except: pass
       try:    self.connection.close()
       except: pass

       self.connection = None
       self.channel    = None

   def connect(self):

       if self.sleeping != None :
          self.asleep = self.sleeping()

       if self.asleep : return

       while True:
          try:
               # connect
               self.logger.debug("Connecting %s %s " % (self.host,self.user) )
               self.connection = amqp.Connection(self.host, userid=self.user, password=self.passwd, ssl=self.ssl)
               self.channel    = self.connection.channel()
               self.logger.debug("Connected ")
               for func in self.rebuilds:
                   func()
               break
          except:
               if not self.loop : sys.exit(1)
               (stype, svalue, tb) = sys.exc_info()
               self.logger.error("AMQP Sender cannot connected to: %s" % self.host)
               self.logger.error("Type=%s, Value=%s" % (stype, svalue))
               self.logger.error("Sleeping 5 seconds ...")
               time.sleep(5)


   def reconnect(self):
       self.close()
       self.connect()

# ==========
# Consumer
# ==========

class Consumer:

   def __init__(self,hostconnect):

      self.hc       = hostconnect
      self.logger   = self.hc.logger
      self.prefetch = 0

      self.exchange_type = 'topic'

      self.hc.add_build(self.build)

   def add_prefetch(self,prefetch):
       self.prefetch = prefetch

   def build(self):
       self.logger.debug("building consumer")
       if self.prefetch != 0 :
          prefetch_size = 0      # dont care
          a_global      = False  # only apply here
          self.channel.basic_qos(prefetch_size,self.prefetch,a_global)

   def ack(self,msg):
       self.logger.debug("--------------> ACK")
       self.logger.debug("--------------> %s" % msg.delivery_tag )
       self.hc.channel.basic_ack(msg.delivery_tag)

   def consume(self,queuename):

       msg = None

       if not self.hc.asleep :
              try :
                     msg = self.hc.channel.basic_get(queuename)
              except :
                     if self.hc.loop :
                        self.hc.reconnect()
                        self.logger.info("consume resume ok")
                        if not self.hc.asleep : msg = self.consume(queuename)
       else:
              time.sleep(5)

       if msg == None : time.sleep(0.01)
       if msg != None : self.logger.debug("--------------> GOT")

       return msg

# ==========
# Exchange 
# ==========

class Exchange:

   def __init__(self,hostconnect,name):
       self.hc     = hostconnect
       self.logger = self.hc.logger
       self.name   = name
       self.exchange_type = 'topic'
       self.hc.add_build(self.build)

   def build(self):
       self.logger.debug("building exchange %s" % self.name)
       self.hc.channel.exchange_declare(self.name, self.exchange_type, auto_delete=False)

# ==========
# Publisher
# ==========

class Publisher:

   def __init__(self,hostconnect):
       self.hc     = hostconnect
       self.logger = self.hc.logger
       self.hc.add_build(self.build)

   def build(self):
       self.logger.debug("building publisher")
       self.hc.channel.tx_select()

   def publish(self,exchange_name,exchange_key,message,filename):
       try :
              hdr = {'filename': filename }
              msg = amqp.Message(message, content_type= 'text/plain',application_headers=hdr)
              self.hc.channel.basic_publish(msg, exchange_name, exchange_key )
              self.hc.channel.tx_commit()
       except :
              time.sleep(5)
              self.hc.reconnect()
              if self.hc.asleep : return
              self.publish(exchange_name,exchange_key,message,filename)

# ==========
# Queue
# ==========

class Queue:

   def __init__(self,hc,qname,auto_delete=False):

       self.hc          = hc
       self.logger      = self.hc.logger
       self.name        = qname
       self.qname       = qname
       self.auto_delete = False

       self.expire      = 0
       self.message_ttl = 0

       self.bindings    = []

       self.hc.add_build(self.build)

   def add_binding(self,exchange_name,exchange_key):
       self.bindings.append( (exchange_name,exchange_key) )

   def add_expire(self, expire):
       self.expire = expire

   def add_message_ttl(self, message_ttl):
       self.message_ttl = message_ttl

   def bind(self, exchange_name,exchange_key):
       self.hc.channel.queue_bind(self.qname, exchange_name, exchange_key )

   def build(self):
       self.logger.debug("building queue %s" % self.name)

       # queue arguments
       args = {}
       if self.expire > 0 :
          args   = {'x-expires' : self.expire }
       if self.message_ttl > 0 :
          args   = {'x-message-ttl' : self.message_ttl }

       # create queue
       self.qname, msg_count, consumer_count = \
       self.hc.channel.queue_declare( self.name,
                                      passive=False, durable=False, exclusive=False,
                                      auto_delete=self.auto_delete,
                                      nowait=False,
                                      arguments= args )

       # queue bindings
       for exchange_name,exchange_key in self.bindings:
           self.bind(exchange_name, exchange_key )


# ===================================
# checksum of file
# ===================================

def Checksum( filepath, offset=0, length=0 ):
    f = open(filepath,'rb')
    if offset != 0 : f.seek(offset,0)
    if length != 0 : data = f.read(length)
    else:            data = f.read()
    f.close()
    return md5(data).hexdigest(),len(data)

# ===================================
# Chunk of file
# ===================================

def Chunk( chunksize, chksum, filepath ):

    factor = 1
    if chunksize[-1] in 'bB'   : chunksize = chunksize[:-1]
    if chunksize[-1] in 'kK'   : factor = 1024
    if chunksize[-1] in 'mM'   : factor = 1024 * 1024
    if chunksize[-1] in 'gG'   : factor = 1024 * 1024 * 1024
    if chunksize[-1] in 'tT'   : factor = 1024 * 1024 * 1024 * 1024
    if chunksize[-1].isalpha() : chunksize = chunksize[:-1]
    chunksize = int(chunksize) * factor

    lstat = os.stat(filepath)
    fsiz  = lstat[stat.ST_SIZE]

    if chunksize == 0 or chunksize >= fsiz :
       data_sum,l   = chksum(filepath,0,fsiz)
       return [ (fsiz, 1, 0, 0, 'd', data_sum) ]

    block_count = int(fsiz / chunksize)
    remainder   = fsiz % chunksize
    if remainder > 0 : block_count = block_count + 1

    total = block_count*chunksize
    if remainder > 0 : total = total - chunksize + remainder
    
    if fsiz != total :
       print("\n")
       print("ERROR:  bc       %d " % block_count)
       print("ERROR:  chunksiz %d " % chunksize)
       print("ERROR:  rem      %d " % remainder)
       print("ERROR:  total   %d " % ((block_count-1)*chunksize + remainder))
       print("ERROR:  blocking incorrect\n")
       sys.exit(1)
        
    i=0
    current_block=0
    parts = []
    while i<fsiz:
          data_sum,length = chksum(filepath,i,chunksize)
          parts.append( (chunksize, block_count, remainder, current_block, 'd', data_sum) )
          current_block += 1
          i = i + length

    return parts

# ===================================
# Key for exchange
# v01.dd_notify.relative_filepath
# v01.post.YYYYMMDD.user.relative_filepath
# ===================================

class Key:
      def __init__(self):
          self.version = 'v01'
          self.ktype   = 'post'
          self.day     = time.strftime("%Y%m%d",time.gmtime())
          self.user    = None
          self.lpath   = ''

      def from_key(self,key):
          self.key = key
          parts = key.split('.')
          self.version = parts[0]
          if self.version == 'v01' :
             self.ktype   = parts[1]
             self.day     = parts[2]
             self.user    = parts[3]
             self.lpath   = os.sep.join(parts[4:])

          if self.version == 'v00' :
             self.ktype = 'dd.notify'
             self.user  = None
             self.day   = None
             self.lpath = os.sep.join(parts[3:])

      def get(self):
          self.key = self.version
          self.key = self.key + '.%s' % self.ktype
          if self.version == 'v01' :
             self.key = self.key + '.%s' % self.day
             self.key = self.key + '.%s' % self.user
          self.key = self.key + '.%s' % self.lpath.replace(os.sep,'.')
          self.key = self.key.replace('..','.')
          if self.key[-1] == '.' : self.key = self.key[:-1]
          return self.key

      def set(self, user, lpath ):
          self.user  = user
          self.lpath = lpath

# ===================================
# mkdir
# ===================================

def mkdir(filepath):
    parts = filepath.split(os.sep)
    apath = ''
    for d in parts[:-1] :
        if d == '' : continue
        apath += os.sep + d
        if os.path.isdir(apath) : continue
        os.mkdir(apath,0o775)

# ==========
# Notice
# ==========

class Notice:
      def __init__(self):
          msec = '.%d' % (int(round(time.time() * 1000)) %1000)
          now  = time.strftime("%Y%m%d%H%M%S",time.gmtime()) + msec
          self.time          = now

          self.chunksize     = 0
          self.block_count   = 0
          self.remainder     = 0
          self.current_block = 0
          self.type_sum      = ''
          self.data_sum      = ''

          self.tag           = ''

          self.source        = ''
          self.lpath         = ''

          self.code          = None
          self.server        = ''
          self.user          = ''
          self.download_time = 0.0

      # get notice from its settings
      def get(self):

          self.notice = self.time   
          self.notice = self.notice + ' %d' % self.chunksize
          self.notice = self.notice + ' %d' % self.block_count
          self.notice = self.notice + ' %d' % self.remainder
          self.notice = self.notice + ' %d' % self.current_block
          self.notice = self.notice + ' %c' % self.type_sum
          self.notice = self.notice + ' %s' % self.data_sum
          self.notice = self.notice + ' %s' % self.tag
          self.notice = self.notice + ' %s' % self.source
          self.notice = self.notice + ' %s' % self.lpath

          if self.code != None :
             self.notice = self.notice + ' %s'  % self.code
             self.notice = self.notice + ' %s'  % self.server
             self.notice = self.notice + ' %s'  % self.user
             self.notice = self.notice + ' %s'  % self.download_time
          
          return self.notice

      # set notice from its string
      def from_notice(self,notice):

          parts = notice.split(' ')

          self.time          = parts[0]
          self.chunksize     = int(parts[1])
          self.block_count   = int(parts[2])
          self.remainder     = int(parts[3])
          self.current_block = int(parts[4])
          self.type_sum      = parts[5]
          self.data_sum      = parts[6]
          self.tag           = parts[7]

          self.source        = parts[8]
          self.lpath         = parts[9]
          self.dpath         = parts[9]

          sparts = self.dpath.split('/')
          self.dfile         = sparts[-1]

          self.url           = self.source

          if self.url[-1] == '/' :
             self.url   = self.url + self.lpath

          # log notice
          if len(parts) > 10 :
             self.code          = parts[10]
             self.server        = parts[11]
             self.user          = parts[12]
             self.download_time = parts[13]

      # set chunk info
      def set_chunk(self,chunksize,block_count,remainder,current_block,type_sum,data_sum):
          self.chunksize     = chunksize
          self.block_count   = block_count
          self.remainder     = remainder
          self.current_block = current_block
          self.type_sum      = type_sum
          self.data_sum      = data_sum

      # set log info
      def set_log(self,code,user,download_time=0.0):
          self.code          = None
          self.server        = socket.gethostname()
          self.user          = user
          self.download_time = 0.0

      # set source info
      def set_source(self,source,lpath):
          self.source = source
          self.lpath  = lpath

      # set tag info
      def set_tag(self,tag):
          self.tag           = tag

# ===================================
# Seek info
# ===================================

def Seekinfo( chunksize, block_count, remainder, current_block ):
    chunksize     = int(chunksize)
    block_count   = int(block_count)
    remainder     = int(remainder)
    current_block = int(current_block)

    offset = current_block * chunksize
    length = chunksize
    if remainder > 0 and current_block == block_count-1 : length = remainder

    fsiz   = block_count * chunksize
    if remainder > 0 : fsiz = fsiz - chunksize + remainder

    return offset,length,fsiz

# ==========
# URL
# ==========

class URL:
      def __init__(self):
         self.error    = False
         self.url      = None
         self.protocol = None
         self.host     = None
         self.port     = None
         self.user     = None
         self.password = None
         self.puphp    = None
         self.path     = None
         self.filename = None

      # get url from pieces
      def get(self):
          self.error   = False
          url          = None
          try :
                hp = self.host
                if self.port     != None : hp += ':' + self.port
                up = self.user
                if self.password != None : up += ':' + self.password
                credentials = hp
                if up != None : credentials = up + '@' + hp

                url = self.protocol + '://' + credentials + '/'
                if self.path != None : url += self.path
                self.url = url

                if self.protocol  == '' : raise error
                if self.host      == '' : raise error
                if self.port      == '' : raise error
                if self.user      == '' : raise error
                if self.password  == '' : raise error
          except:
                self.error = True

          return url

      # get url from pieces
      def get_nocredential(self):
          self.error   = False
          url          = None
          try :
                hp = self.host
                if self.port     != None : hp += ':' + self.port
                url = self.protocol + '://' + hp + '/'
                if self.path != None : url += self.path
                self.url = url

                if self.protocol  == '' : raise error
                if self.host      == '' : raise error
                if self.port      == '' : raise error
          except:
                self.error = True

          return url

      # set pieces from url
      def set(self,url):
          self.error = False
          self.url   = url
          try :
                slashes = url.split('/')
                self.protocol = slashes[0][:-1]
                credentials   = slashes[2].split('@')
                parts         = credentials[-1].split(':')
                self.host     = parts[0]
                if len(parts) == 2 : self.port = parts[-1]
                if len(credentials) == 2 :
                   parts      = credentials[0].split(':')
                   self.user  = parts[0]
                   if len(parts)    == 2  : self.password = parts[-1]
                if len(slashes) >= 4  : self.path = '/'.join(slashes[3:])
                if slashes[-1]  != '' : self.filename = slashes[-1]

                if slashes[1]     != '' : raise error
                if slashes[0][-1] != ':': raise error
                if self.protocol  == '' : raise error
                if self.host      == '' : raise error
                if self.port      == '' : raise error
                if self.user      == '' : raise error
                if self.password  == '' : raise error
          except:
                self.error = True

# ===================================
# MAIN
# ===================================

def help(logger):
    logger.info("Usage: dd_post [-r] [-b blocksize] [-w tag] [basedir] <source-url> <destination-url>")
    logger.info("default blocksize 0")
    logger.info("default tag ''")

def main():

    LOG_FORMAT = ('%(asctime)s [%(levelname)s] %(message)s')
    logger     = logging.getLogger(__name__)
    logging.basicConfig(level=logging.INFO, format=LOG_FORMAT)

    chunksize = '0'
    taginfo   = 'default'
    randomiz  = False

    #get options arguments
    try:   opts, args = getopt.getopt(sys.argv[1:],'hrb:w:',['help'])
    except getopt.GetoptError as err:    
           logger.error("%s" % err )      
           logger.info("Try `dd_post --help' for more information.")
           sys.exit(7)                    
    
    #validate options
    if opts == [] and args == []:
      help(logger)  
      sys.exit(8)

    for opt, value in opts:
        if opt in ('-h','--help'):
             help(logger)
             sys.exit(0)
        elif opt in ('-b'):
             chunksize = value        
        elif opt in ('-r'):
             randomiz = True        
        elif opt in ('-w'):
             taginfo = value       

    if len(args) < 2 :
       help(logger)
       sys.exit(9)
        
    #validate amqp url
    destination = URL()
    destination.set(args[-1])
    if destination.protocol != 'amqp' or destination.user == None or destination.error :
       logger.error("destination url %s " % args[-1] )
       sys.exit(10)

    #validate source url
    source = URL()
    source.set(args[-2])
    if not source.protocol in ['http','sftp']             : source.error = True
    if source.protocol == 'sftp' and source.user  == None : source.error = True
    if source.path     == None   or \
       source.path     == ''     or \
       source.path[-1] == '/'       : source.error = True
    if source.error :
       logger.error("source url %s " % args[-2] )
       sys.exit(11)

    #
    # check for relative path and find real filepath
    #

    filepath = source.path

    if source.protocol == 'http' or \
     ( source.protocol == 'sftp' and source.path[0] != '/' ) :
       if len(args) < 3 :
          logger.error("no basedir in %s " % args )
          sys.exit(12)
       filepath = args[-3] + '/' + source.path

    #
    # verify that file exists
    #

    if not os.path.isfile(filepath):
       logger.error("File not found %s " % filepath )
       sys.exit(13)

    #
    # fix destination path if needed
    #
    dpath = ''
    if destination.path == None or destination.path == '' :
       dpath = source.path
    else :
       if destination.path[0] != '/' : dpath += '/'
       dpath += destination.path

    if dpath[-1] == '/' :
       dpath += source.filename

    destination.path = dpath
    destination.set(destination.get())
    if destination.error :
       logger.error("Error destination url incorrect %s " % destination.url )
       sys.exit(14)

    if destination.path == source.path :
       source.path = None
       source.set(source.get())

    #
    # file chunk 
    #
    parts = Chunk(chunksize,Checksum,filepath)

    # ==============
    # publisher part
    # ==============

    # publisher host connection

    hc_pub = HostConnect( destination.host,destination.user,destination.password,\
                          logger = logger, loop=False)
    hc_pub.connect()

    # publisher

    pub = Publisher(hc_pub)
    pub.build()

    # pub exchange name "make sure it exists"

    exchange_name = 'sx_' + destination.user
    ex = Exchange(hc_pub,exchange_name)
    ex.build()

    # ==============
    # consumer part
    # ==============

    hc_con = HostConnect( destination.host,destination.user,destination.password,\
                          logger = logger, loop=False)
    hc_con.connect()

    # consumer

    consumer = Consumer(hc_con)
    consumer.build()

    # log queue

    name  = ''
    log_queue = Queue(hc_con,name)
    log_queue.add_expire(len(parts)*10*1000)
    log_queue.build()

    #
    # randomize chunks
    #
    if randomiz and len(parts)>1 :
       rparts = []
       rmax   = len(parts)
       i      = 0

       rparts.extend(parts)
       while i < rmax :
           j         = random.randint(0,rmax-1)
           tmp       = rparts[j]
           rparts[j] = rparts[i]
           rparts[i] = tmp
           i = i + 1

       parts = rparts

    #
    # build product exchange key
    #

    post_key = Key()
    post_key.set(destination.user, destination.path )
    str_key  = post_key.get()
    logger.info(" Key %s" % str_key )

    #
    # build product log exchange key and bind it
    #

    log_key = Key()
    log_key.ktype = 'log'
    log_key.set(destination.user, destination.path )
    logkey  = log_key.get()
    log_queue.bind(exchange_name,logkey)

    #
    # build notice class
    #

    notice = Notice()
    notice.set_source(source.get(),destination.path)
    notice.set_tag(taginfo)

    #
    # loop on all file chunk
    #

    for c in parts :

        chunksize, block_count, remainder, current_block, sum_typ, sum_data = c

        notice.set_chunk(chunksize, block_count, remainder, current_block, sum_typ, sum_data)
        str_notice = notice.get()

        logger.info(" Notice %s \n" % str_notice )

        # publish
        pub.publish( exchange_name, str_key, str_notice, destination.filename )


    # get message log
    time.sleep(2.0)
    for c in parts :
        msg=consumer.consume(log_queue.qname)
        if msg == None :
               logger.info("%s"% msg) 
        else :
               logger.info("%s"% msg.body) 
               consumer.ack(msg)

    hc_pub.close()
    hc_con.close()
    sys.exit(0)

if __name__ == '__main__':
    main()
